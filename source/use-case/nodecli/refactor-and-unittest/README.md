---
author: laco 
---

# ユニットテストを記述する {#unit-test}

このセクションでは、これまで作成したCLIアプリケーションにユニットテストを導入します。
ユニットテストの導入とあわせて、ソースコードを整理してテストがしやすくなるようにモジュール化します。

## スクリプトをモジュールに分割する {#split-script}

前のセクションまでは、すべての処理をひとつのJavaScriptファイルに記述していました。
ユニットテストを行うためにはテスト対象がモジュールとして分割されていなければいけません。
今回のアプリケーションでは、CLIアプリケーションとしてコマンドライン引数を処理する部分と、MarkdownをHTMLへ変換する部分に分割します。

Node.jsでは、複数のJavaScriptファイル間で変数や関数などをやりとりするために、モジュールという仕組みを利用します。
モジュールとは変数や関数などを外部にエクスポートするJavaScriptファイルのことです。
モジュールであるJavaScriptファイルは、別のJavaScriptファイルからインポートできます。
モジュールからオブジェクトをエクスポートするには、Node.jsのグローバル変数である[moduleオブジェクト][]を利用します。
`module.exports`オブジェクトは、そのファイルからエクスポートされるオブジェクトを格納します。
次のコードは簡単な関数をエクスポートするモジュールの例です。

[import, greet.js](src/example/greet.js)

`require`関数は別のJavaScriptファイルをモジュールとしてインポートできます。
次の例では先ほどのモジュールをインポートして、エクスポートされた関数を取得しています。

[import, greet-index.js](src/example/greet-index.js)

`module.exports`オブジェクトに直接代入するのではなく、そのプロパティとして任意の値をエクスポートできます。
次の例では2つの関数を同じファイルからエクスポートしています。

[import, functions.js](src/example/functions.js)

このようにエクスポートされたオブジェクトは、`require`関数の戻り値のプロパティとしてアクセス可能になります。

[import, functions-index.js](src/example/functions-index.js)

それではCLIアプリケーションのソースコードをモジュールに分割してみましょう。
`md2html.js`という名前のJavaScriptファイルを作成し、次のようにMarkdownの変換処理を記述します。

[import md2html.js](./src/md2html.js)

このモジュールがエクスポートするのは、与えられたオプションをもとにMarkdown文字列をHTMLに変換する関数です。
アプリケーションのエントリポイントである`main.js`では、次のようにこのモジュールをインポートして使用します。

[import main.js](./src/main.js)

markedパッケージや、そのオプションに関する記述がひとつの`md2html`関数に隠蔽され、`main.js`がシンプルになりました。
そして`md2html.js`はアプリケーションから独立したひとつのモジュールとして切り出され、ユニットテストが可能になりました。

## ユニットテスト実行環境を作る {#create-env}

ユニットテストの実行にはさまざまな方法がありますが、
このセクションではテスティングフレームワークとして[Mocha][]を使って、ユニットテストの実行環境を作成します。
Mochaが提供するテスト実行環境では、グローバルに`it`や`describe`などの関数が定義されます。
`it`関数はその内部でエラーが発生したとき、そのテストを失敗として扱います。
つまり、期待する結果と異なるならエラーを投げ、期待どおりならエラーを投げないというテストコードを書くことになります。

テストコード中でエラーを投げるために、今回はNode.jsの標準モジュールのひとつである[assertモジュール][]から提供される`assert`関数を利用します。
`assert`関数は引数の評価結果がfalseであるとき、実行時にエラーを投げます。

Mochaによるテスト環境を作るために、まずは次のコマンドで`mocha`パッケージをインストールします。

```shell-session
$ npm install --save-dev mocha
```

`--save-dev`オプションは、パッケージを`devDependencies`としてインストールするためのものです。
package.jsonの`devDependencies`には、そのパッケージを開発するときだけ必要な依存ライブラリを記述します。

ユニットテストを実行するには、Mochaが提供する`mocha`コマンドを使います。
Mochaをインストールした後、package.jsonの`scripts`プロパティを次のように記述します。

```json
{
    ...
    "scripts": {
        "test": "mocha"
    },
    ...
}
```

この記述により、`npm test`コマンドを実行したときに`mocha`コマンドが呼び出されます。
試しに`npm test`コマンドを実行し、Mochaによるテストが行われることを確認しましょう。
まだ何もテストを書いていないので、`0 passing`と表示されます。


```shell-session
$ npm test
> mocha

 0 passing (2ms)
```

## ユニットテストを記述する {#write-unit-test}

テストの実行環境ができたので、実際にユニットテストを記述します。
Mochaのユニットテストは`test`ディレクトリの中にJavaScriptファイルを配置して記述します。
`test/md2html-test.js`ファイルを作成し、`md2html.js`に対するユニットテストを次のように記述します。

[import test/md2html-test.js](./src/test/md2html-test.js)

`it`関数で定義したユニットテストは、`md2html`関数の変換結果が期待するものになっているかをテストしています。
`test/fixtures`ディレクトリにはユニットテストで用いるファイルを配置しています。
今回は変換元のMarkdownファイルと、期待する変換結果のHTMLファイルの2つが存在します。

ユニットテストを記述したら、もう一度改めて`npm test`コマンドを実行しましょう。1件のテストが通れば成功です。

```shell-session
$ npm test
> mocha

  ✓ converts Markdown to HTML

  1 passing (18ms)
```

## なぜユニットテストをおこなうのか {#reason-for-unit-test}

ユニットテストを実施することには多くの利点があります。
早期にバグが発見できることや、安心してリファクタリングをおこなえるようになるのはもちろんですが、
ユニットテストが可能な状態を保つこと自体に意味があります。
実際にテストをおこなわなくてもテストしやすいコードになるよう心がけることが、アプリケーションを適切にモジュール化する指針になります。

またユニットテストには生きたドキュメントとしての側面もあります。
ドキュメントはこまめにメンテナンスされないとすぐに実際のコードと齟齬が生まれてしまいますが、
ユニットテストはそのモジュールが満たすべき仕様を表すドキュメントとして機能します。

ユニットテストの記述は手間がかかるだけのようにも思えますが、
中長期的にアプリケーションをメンテナンスする場合にはかかせないものです。
そしてよいテストを書くためには、日頃からテストを書く習慣をつけておくことが重要です。

## まとめ {#unit-test-summary}

このユースケースの目標であるNode.jsを使ったCLIアプリケーションの作成と、ユニットテストの導入ができました。
npmを使ったパッケージ管理や外部モジュールの利用、fsモジュールを使ったファイル操作など、多くの要素が登場しました。
これらはNode.jsアプリケーション開発においてほとんどのユースケースで応用されるものなので、よく理解しておきましょう。

[moduleオブジェクト]: https://nodejs.org/api/modules.html#modules_the_module_object
[Mocha]: https://mochajs.org/
[assertモジュール]: https://nodejs.org/api/assert.html
