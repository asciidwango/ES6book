---
author: azu
---

# 関数とスコープ

定義された関数はそれぞれのスコープを持っています。スコープとは変数や関数の引数などを参照できる範囲を決めるものです。
JavaScriptでは、新しい関数を定義するとその関数に紐付けられた新しいスコープを作成します。関数を定義するということは処理をまとめるというだけではなく、変数が有効な範囲を決める新しいスコープを作っているといえます。

スコープの仕組みを理解することは関数をより深く理解することにつながります。なぜなら関数とスコープは密接な関係を持っているためです。
この章では関数とスコープの関係を中心に、スコープとはどのような働きをしていて、スコープ内では変数の名前から値がどのように取得されているのかを見ていきます。

JavaScriptのスコープは、ES2015において直感的に理解しやすい仕組みが整備されました。
基本的にはES2015以降の仕組みを理解していればコードを書く場合には問題ありません。

しかし、既存のコードを理解するためには、ES2015より前に決められた古い仕組みについても知る必要があります。
なぜなら、既存のコードは古い仕組みを使って書かれていることもあるためです。
また、JavaScriptでは古い仕組みと新しい仕組みを混在して書くことができます。
古い仕組みによるスコープは直感的でない挙動も多いため、コラムで補足していきます。

## スコープとは

スコープとは変数の名前や関数などの参照できる範囲を決めるものです。
スコープの中で定義された変数はスコープ内でのみ参照でき、スコープの外側からは参照できません。

身近なスコープの例として関数によるスコープを見ていきます。
次のコードには、`fn`関数のブロック（`{`と`}`）内で変数`x`を定義しています。
この変数`x`は`fn`関数のスコープに定義されているため、`fn`関数の内側では参照できます。
一方、`fn`関数の外側から変数`x`は参照できないため`ReferenceError`をなげます。

```js
function fn() {
    const x = 1;
    // fn関数のスコープ内から`x`は参照できる
    console.log(x); // => 1
}
fn();
// fn関数のスコープ外から`x`は参照できないためエラー
console.log(x); // => ReferenceError: x is not defined
```

このコードを見て分かるように、変数`x`は`fn`関数のスコープに紐付けて定義されます。
そのため、変数`x`は`fn`関数のスコープ内でのみ参照できます。

関数は**仮引数**をもつことができますが、仮引数は関数のスコープに紐付けて定義します。
そのため、仮引数はその関数の中でのみ参照が可能で、関数の外からは参照できません。

<!-- Note: 関数の仮引数はvarで宣言されたものと同じ扱い

関数の宣言
- Set F.[[FormalParameters]] to ParameterList.
- https://tc39.github.io/ecma262/#sec-functioninitialize
- function objectの[[Environment]]ではなく、[[FormalParameters]]に代入される
- 仮引数は関数のスコープではなくfunction objectに紐づく

関数の初期化処理
- https://tc39.github.io/ecma262/#sec-functiondeclarationinstantiation
- [[FormalParameters]]は初期化時に`varEnv`に対して代入される
- つまり、仮引数はvarで宣言しているのと同じになる
- スコープという意味では内側のみから参照でき、外からは参照できないという点で同じ

 -->

```js
function fn(arg) {
    // fn関数のスコープ内から仮引数`arg`は参照できる
    console.log(arg); // => 1
}
fn(1);
// fn関数のスコープ外から`arg`は参照できないためエラー
console.log(arg); // => ReferenceError: arg is not defined
```

この関数によるスコープのことを**関数スコープ**と呼びます。

[変数と宣言][]の章にて、`let`や`const`は同じスコープ内に同じ識別子で二重に定義できないという話をしました。
これは、各スコープには同じ識別子の変数は1つしか宣言できないためです。（`var`とfunction宣言は例外的に可能ですが、詳細は後述します）

[import, identifier-duplicated-invalid](./src/identifier-duplicated-invalid.js)

一方、スコープが異なれば同じ識別子で変数を宣言できます。
次の例では、`fnA`関数と`fnB`関数という異なるスコープで、それぞれ変数`x`を定義できていることが分かります。

```js
// 異なる関数のスコープには同じ"x"を定義できる
function fnA() {
    let x;
}
function fnB() {
    let x;
}
```

このように、スコープが異なれば同じ名前の変数を定義できます。
スコープの仕組みがないと、グローバルな空間な一意な変数名を考える必要があります。
スコープがあることで適切な名前の変数を定義できるようになるため、スコープの役割は重要です。

## ブロックスコープ

`{`と`}`で囲んだ範囲をブロックと呼びます。（「[文と式][]」の章を参照）
ブロックもスコープを作成します。
ブロック内で宣言された変数は、スコープ内でのみ参照でき、スコープの外側からは参照できません。

```js
// ブロック内で定義した変数はスコープ内でのみ参照できる
{
    const x = 1;
    console.log(x); // => 1
}
// スコープの外から`x`を参照できないためエラー
console.log(x); // => ReferenceError: x is not defined
```

ブロックによるスコープのことを**ブロックスコープ**と呼びます。

if文やwhile文などもブロックスコープを作成します。
単独のブロックと同じく、ブロックの中で宣言した変数は外から参照できません。

```js
// if文のブロック内で定義した変数はブロックスコープの中でのみ参照できる
if (true) {
    const x = "inner";
    console.log(x); // => "inner"
}
console.log(x); // => ReferenceError: x is not defined
```

for文は、ループごとに新しいブロックスコープを作成します。
このことは「各スコープには同じ識別子の変数は1つしか宣言できない」のルールを考えてみると分かりやすいです。
次のコードでは、ループ毎に`const`で`element`変数を定義していますが、エラーなく定義できています。
これは、ループ毎に別々のブロックスコープが作成され、変数の宣言もそれぞれ別々のスコープで行われるためです。

```js
const array = [1, 2, 3, 4, 5];
// ループごとに新しいブロックスコープを作成する
for (const element of array) {
    // forのブロックスコープの中でのみ`element`を参照できる
    console.log(element);
}
// ループの外からはブロックスコープ内の変数は参照できない
console.log(element); // => ReferenceError: element is not defined
```

<!-- Note: forとブロックスコープの仕様

- 仕様ではforをIterateする際に`CreatePerIterationEnvironment`で新しい NewDeclarativeEnvironmentを作成している
- [9. Variables and scoping](http://exploringjs.com/es6/ch_variables.html#sec_let-const-loop-heads)
- [ECMAScript 2015 Language Specification – ECMA-262 6th Edition](http://www.ecma-international.org/ecma-262/6.0/#sec-createperiterationenvironment)

 -->

## スコープチェーン

関数やブロックはネスト（入れ子）して書けますが、同様にスコープもネストできます。
次のコードではブロックの中にブロックを書いています。
このとき外側のブロックスコープのことを`OUTER`、内側のブロックスコープのことを`INNER`と呼ぶことにします。

```js
{
    // OUTERブロックスコープ
    {
        // INNERブロックスコープ
    }
}
```

スコープがネストしている場合に、内側のスコープから外側のスコープにある変数を参照できます。
次のコードでは、内側のINNERブロックスコープから外側のOUTERブロックスコープに定義されている変数`x`を参照できます。
これは、ブロックスコープに限らず関数スコープでも同様です。

```js
{
    // OUTERブロックスコープ
    const x = "x";
    {
        // INNERブロックスコープからOUTERブロックスコープの変数を参照できる
        console.log(x); // => "x"
    }
}
```

このとき、現在のスコープ（変数を参照する式が書かれているスコープ）から外側のスコープへと順番に変数が定義されているかを確認します。このとき、内側のINNERブロックスコープには変数`x`はありませんが外側のOUTERブロックスコープに変数`x`が定義されているため参照できます。つまり次のようなステップで参照したい変数を探索しています。

1. INNERブロックスコープに変数`x`があるかを確認 => ない
2. ひとつ外側のOUTERブロックスコープに変数`x`があるかを確認 => ある

一方、現在のスコープも含めどの外側のスコープに該当する変数が定義されていない場合は、`ReferenceError`の例外が発生します。
次の例では、どのスコープにも存在しない`xyz`を参照しているため、`ReferenceError`の例外が発生します。

```js
{
    // OUTERブロックスコープ
    {
        // INNERブロックスコープ
        console.log(xyz); // => ReferenceError: xyz is not defined
    }
}
```

このときも、現在のスコープ（変数を参照する式が書かれているスコープ）から外側のスコープへと順番に変数が定義されているかを確認します。しかし、どのスコープにも変数`xyz`は定義されていないため、`ReferenceError`の例外が発生します。つまり次のようなステップで参照したい変数を探索しています。

1. INNERブロックスコープに変数`xyz`があるかを確認 => ない
2. ひとつ外側のOUTERブロックスコープに変数`xyz`があるかを確認 => ない
3. 一番外側のスコープにも変数`xyz`は定義されていない => `ReferenceError`が発生

この内側から外側のスコープへと順番に変数が定義されているか探す仕組みのことを**スコープチェーン**と呼びます。

内側と外側のスコープ両方に同じ名前の変数が定義されている場合もスコープチェーンの仕組みで解決できます。
次のコードでは、内側のINNERブロックスコープと外側のOUTERブロックスコープに同じ名前の変数`x`が定義されています。
スコープチェーンの仕組みより、現在のスコープに定義されている変数`x`を優先的に参照します。

```js
{
    // OUTERブロックスコープ
    const x = "outer";
    {
        // INNERブロックスコープ
        const x = "inner";
        // 現在のスコープ(INNERブロックスコープ)にある`x`を参照する
        console.log(x); // => "inner"
    }
    // 現在のスコープ(OUTERブロックスコープ)にある`x`を参照する
    console.log(x); // => "outer"
}
```

このようにスコープは階層的な構造となっており、その際にどの変数が参照できるかはスコープチェーンによって解決されています。

## グローバルスコープ

- グローバルスコープ
- グローバル変数
- ビルトイン関数
- シャドーイングの実害

## [コラム] スコープは小さく

- 大きなスコープに変数を定義することはそれだけ依存や影響範囲を広げている
- 小さなスコープに必要な変数を定義する or 引数で必要な変数を受け取るのが基本

## varとfunction宣言の例外

この章では意図的に`var`についての解説を省いています。なぜなら`var`を使うべきケースはないからです。
これから各コードは必ず`let`か`const`を利用してください。
しかし、`var`を含むコードなどを読む際には、`var`特有の巻き上げという仕組みについて理解する必要があります。

- hoisting
- varは関数スコープにbindする
- functionもhositingする

## ローカル変数の寿命とガーベッジコレクション

## クロージャー

- ファクトリとしての関数
- IIFE

[変数と宣言]: ../variables/README.md
[文と式]: ../statement-expression/README.md
