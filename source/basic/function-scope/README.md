---
author: azu
---

# 関数とスコープ

定義された関数はそれぞれのスコープを持っています。スコープとは変数や関数の引数などを参照できる範囲を決めるものです。
JavaScriptでは、新しい関数を定義するとその関数に紐付けられた新しいスコープを作成します。関数を定義するということは処理をまとめるというだけではなく、変数が有効な範囲を決める新しいスコープを作っているといえます。

スコープの仕組みを理解することは関数をより深く理解することにつながります。なぜなら関数とスコープは密接な関係を持っているためです。
この章では関数とスコープの関係を中心に、スコープとはどのような働きをしていて、スコープ内では変数の名前から値がどのように取得されているのかを見ていきます。

JavaScriptのスコープは、ES2015において直感的に理解しやすい仕組みが整備されました。
基本的にはES2015以降の仕組みを理解していればコードを書く場合には問題ありません。

しかし、既存のコードを理解するためには、ES2015より前に決められた古い仕組みについても知る必要があります。
なぜなら、既存のコードは古い仕組みを使って書かれていることもあるためです。
また、JavaScriptでは古い仕組みと新しい仕組みを混在して書くことができます。
古い仕組みによるスコープは直感的でない挙動も多いため、コラムで補足していきます。

## スコープとは

スコープとは変数の名前や関数などの参照できる範囲を決めるものです。
スコープの中で定義された変数はスコープ内からのみ参照でき、スコープの外側からは参照できません。

身近なスコープの例として関数によるスコープを見ていきます。
次のコードには、`fn`関数のブロック（`{`と`}`）内で変数`x`を定義しています。
この変数`x`は`fn`関数のスコープに定義されているため、`fn`関数の内側では参照できます。
一方、`fn`関数の外側から変数`x`は参照できないため`ReferenceError`をなげます。

```js
function fn() {
    const x = 1;
    // fn関数のスコープ内から`x`は参照できる
    console.log(x); // => 1
}
fn();
// fn関数のスコープ外から`x`は参照できないためエラー
console.log(x); // => ReferenceError: x is not defined
```

このコードを見て分かるように、変数`x`は`fn`関数のスコープに紐付けて定義されます。
そのため、変数`x`は`fn`関数のスコープ内（関数のブロック内）からのみ参照できます。

関数は**仮引数**をもつことができますが、仮引数は関数のスコープに紐付けて定義します。
そのため、仮引数はその関数の中でのみ参照が可能で、関数の外からは参照できません。

<!-- Note: 関数の仮引数はvarで宣言されたものと同じ扱い

関数の宣言
- Set F.[[FormalParameters]] to ParameterList.
- https://tc39.github.io/ecma262/#sec-functioninitialize
- function objectの[[Environment]]ではなく、[[FormalParameters]]に代入される
- 仮引数は関数のスコープではなくfunction objectに紐づく

関数の初期化処理
- https://tc39.github.io/ecma262/#sec-functiondeclarationinstantiation
- [[FormalParameters]]は初期化時に`varEnv`に対して代入される
- つまり、仮引数はvarで宣言しているのと同じになる
- スコープという意味では内側のみから参照でき、外からは参照できないという点で同じ

 -->

```js
function fn(arg) {
    // fn関数のスコープ内から仮引数`arg`は参照できる
    console.log(arg); // => 1
}
fn(1);
// fn関数のスコープ外から`arg`は参照できないためエラー
console.log(arg); // => ReferenceError: arg is not defined
```

[変数と宣言](../variables/README.md)の章にて、`let`や`const`は同じスコープ内に同じ識別子で二重に定義できないという話をしました。
これは、各スコープには同じ識別子の変数は1つしか宣言できないためです。（`var`やfunction宣言は例外的に可能ですが、詳細は後述します）

[import, identifier-duplicated-invalid](./src/identifier-duplicated-invalid.js)

一方、スコープが異なれば同じ識別子で変数を宣言できます。
次の例では、`fnA`関数と`fnB`関数という異なるスコープで、それぞれ変数`x`を定義できていることが分かります。

```js
// 異なる関数のスコープには同じ"x"を定義できる
function fnA() {
    let x;
}
function fnB() {
    let x;
}
```

このように、スコープが異なれば同じ名前の変数を定義できます。
スコープの仕組みがないと、グローバルな空間な一意な変数名を考える必要があります。
スコープがあることで適切な名前の変数を定義できるようになるため、スコープの役割は重要です。

## グローバルスコープ

- 変数の名前解決

## 関数スコープ

### スコープと名前解決

- 変数と引数の名前解決

## ブロックスコープ

- 変数の名前解決

## [コラム] varの例外

この章では意図的に`var`についての解説を省いています。なぜなら`var`を使うべきケースはないからです。
これから各コードは必ず`let`か`const`を利用してください。
しかし、`var`を含むコードなどを読む際には、`var`特有の巻き上げという仕組みについて理解する必要があります。

- hoisting
- varは関数スコープにbindする
- functionもhositingする

----

## スコープとローカル変数（引数）

- 名前解決の話

### 変数の名前解決

- スコープチェイン
- シャドーイング

----

## ローカル変数の寿命とガーベッジコレクション

## [コラム] スコープは小さく

## クロージャー

- ファクトリとしての関数
- IIFE

## [コラム] グローバルオブジェクト

- [9. Variables and scoping](http://exploringjs.com/es6/ch_variables.html#sect_global-object "9. Variables and scoping")

