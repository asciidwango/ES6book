---
author: azu
---

# 関数とスコープ

定義された関数はそれぞれのスコープを持っています。スコープとは変数や関数の引数などを参照できる範囲を決めるものです。
JavaScriptでは、新しい関数を定義するとその関数に紐付けられた新しいスコープを作成します。関数を定義するということは処理をまとめるというだけではなく、変数が有効な範囲を決める新しいスコープを作っているといえます。

スコープの仕組みを理解することは関数をより深く理解することにつながります。なぜなら関数とスコープは密接な関係を持っているためです。
この章では関数とスコープの関係を中心に、スコープとはどのような働きをしていて、スコープ内では変数の名前から値がどのように取得されているのかを見ていきます。

JavaScriptのスコープは、ES2015において直感的に理解しやすい仕組みが整備されました。
基本的にはES2015以降の仕組みを理解していればコードを書く場合には問題ありません。

しかし、既存のコードを理解するためには、ES2015より前に決められた古い仕組みについても知る必要があります。
なぜなら、既存のコードは古い仕組みを使って書かれていることもあるためです。
また、JavaScriptでは古い仕組みと新しい仕組みを混在して書くことができます。
古い仕組みによるスコープは直感的でない挙動も多いため、コラムで補足していきます。

## スコープとは

スコープとは変数の名前や関数などの参照できる範囲を決めるものです。
スコープの中で定義された変数はスコープ内でのみ参照でき、スコープの外側からは参照できません。

身近なスコープの例として関数によるスコープを見ていきます。
次のコードには、`fn`関数のブロック（`{`と`}`）内で変数`x`を定義しています。
この変数`x`は`fn`関数のスコープに定義されているため、`fn`関数の内側では参照できます。
一方、`fn`関数の外側から変数`x`は参照できないため`ReferenceError`をなげます。

```js
function fn() {
    const x = 1;
    // fn関数のスコープ内から`x`は参照できる
    console.log(x); // => 1
}
fn();
// fn関数のスコープ外から`x`は参照できないためエラー
console.log(x); // => ReferenceError: x is not defined
```

このコードを見て分かるように、変数`x`は`fn`関数のスコープに紐付けて定義されます。
そのため、変数`x`は`fn`関数のスコープ内でのみ参照できます。

関数は**仮引数**をもつことができますが、仮引数は関数のスコープに紐付けて定義します。
そのため、仮引数はその関数の中でのみ参照が可能で、関数の外からは参照できません。

<!-- Note: 関数の仮引数はvarで宣言されたものと同じ扱い

関数の宣言
- Set F.[[FormalParameters]] to ParameterList.
- https://tc39.github.io/ecma262/#sec-functioninitialize
- function objectの[[Environment]]ではなく、[[FormalParameters]]に代入される
- 仮引数は関数のスコープではなくfunction objectに紐づく

関数の初期化処理
- https://tc39.github.io/ecma262/#sec-functiondeclarationinstantiation
- [[FormalParameters]]は初期化時に`varEnv`に対して代入される
- つまり、仮引数はvarで宣言しているのと同じになる
- スコープという意味では内側のみから参照でき、外からは参照できないという点で同じ

 -->

```js
function fn(arg) {
    // fn関数のスコープ内から仮引数`arg`は参照できる
    console.log(arg); // => 1
}
fn(1);
// fn関数のスコープ外から`arg`は参照できないためエラー
console.log(arg); // => ReferenceError: arg is not defined
```

この関数によるスコープのことを**関数スコープ**と呼びます。

[変数と宣言][]の章にて、`let`や`const`は同じスコープ内に同じ名前の変数を二重に定義できないという話をしました。
これは、各スコープには同じ名前の変数は1つしか宣言できないためです。（`var`と`function`による関数宣言は例外的に可能です）

[import, identifier-duplicated-invalid](./src/identifier-duplicated-invalid.js)

一方、スコープが異なれば同じ名前で変数を宣言できます。
次の例では、`fnA`関数と`fnB`関数という異なるスコープで、それぞれ変数`x`を定義できていることが分かります。

```js
// 異なる関数のスコープには同じ"x"を定義できる
function fnA() {
    let x;
}
function fnB() {
    let x;
}
```

このように、スコープが異なれば同じ名前の変数を定義できます。
スコープの仕組みがないと、グローバルな空間な一意な変数名を考える必要があります。
スコープがあることで適切な名前の変数を定義できるようになるため、スコープの役割は重要です。

## ブロックスコープ

`{`と`}`で囲んだ範囲をブロックと呼びます。（「[文と式][]」の章を参照）
ブロックもスコープを作成します。
ブロック内で宣言された変数は、スコープ内でのみ参照でき、スコープの外側からは参照できません。

```js
// ブロック内で定義した変数はスコープ内でのみ参照できる
{
    const x = 1;
    console.log(x); // => 1
}
// スコープの外から`x`を参照できないためエラー
console.log(x); // => ReferenceError: x is not defined
```

ブロックによるスコープのことを**ブロックスコープ**と呼びます。

<!-- Notes: ブロックスコープと仕様

- ブロック`{}`は新しい[NewDeclarativeEnvironment](https://tc39.github.io/ecma262/#sec-newdeclarativeenvironment "NewDeclarativeEnvironment")を作成する
- つまり、新しいLexicalEnviromentというスコープを作成している
- https://tc39.github.io/ecma262/#sec-block-runtime-semantics-evaluation
- そして評価する際に、そのブロック内に宣言されている変数をスコープに対して紐付けている
- https://tc39.github.io/ecma262/#sec-blockdeclarationinstantiation

 -->

if文やwhile文などもブロックスコープを作成します。
単独のブロックと同じく、ブロックの中で宣言した変数は外から参照できません。

```js
// if文のブロック内で定義した変数はブロックスコープの中でのみ参照できる
if (true) {
    const x = "inner";
    console.log(x); // => "inner"
}
console.log(x); // => ReferenceError: x is not defined
```

for文は、ループごとに新しいブロックスコープを作成します。
このことは「各スコープには同じ名前の変数は1つしか宣言できない」のルールを考えてみると分かりやすいです。
次のコードでは、ループ毎に`const`で`element`変数を定義していますが、エラーなく定義できています。
これは、ループ毎に別々のブロックスコープが作成され、変数の宣言もそれぞれ別々のスコープで行われるためです。

```js
const array = [1, 2, 3, 4, 5];
// ループごとに新しいブロックスコープを作成する
for (const element of array) {
    // forのブロックスコープの中でのみ`element`を参照できる
    console.log(element);
}
// ループの外からはブロックスコープ内の変数は参照できない
console.log(element); // => ReferenceError: element is not defined
```

<!-- Note: forとブロックスコープの仕様

- 仕様ではforをIterateする際に`CreatePerIterationEnvironment`で新しい NewDeclarativeEnvironmentを作成している
- [9. Variables and scoping](http://exploringjs.com/es6/ch_variables.html#sec_let-const-loop-heads)
- [ECMAScript 2015 Language Specification – ECMA-262 6th Edition](http://www.ecma-international.org/ecma-262/6.0/#sec-createperiterationenvironment)

 -->

## スコープチェーン

関数やブロックはネスト（入れ子）して書けますが、同様にスコープもネストできます。
次のコードではブロックの中にブロックを書いています。
このとき外側のブロックスコープのことを`OUTER`、内側のブロックスコープのことを`INNER`と呼ぶことにします。

```js
{
    // OUTERブロックスコープ
    {
        // INNERブロックスコープ
    }
}
```

スコープがネストしている場合に、内側のスコープから外側のスコープにある変数を参照できます。
次のコードでは、内側のINNERブロックスコープから外側のOUTERブロックスコープに定義されている変数`x`を参照できます。
これは、ブロックスコープに限らず関数スコープでも同様です。

```js
{
    // OUTERブロックスコープ
    const x = "x";
    {
        // INNERブロックスコープからOUTERブロックスコープの変数を参照できる
        console.log(x); // => "x"
    }
}
```

このとき、現在のスコープ（変数を参照する式が書かれているスコープ）から外側のスコープへと順番に変数が定義されているかを確認します。このとき、内側のINNERブロックスコープには変数`x`はありませんが外側のOUTERブロックスコープに変数`x`が定義されているため参照できます。つまり次のようなステップで参照したい変数を探索しています。

1. INNERブロックスコープに変数`x`があるかを確認 => ない
2. ひとつ外側のOUTERブロックスコープに変数`x`があるかを確認 => ある

一方、現在のスコープも含めどの外側のスコープに該当する変数が定義されていない場合は、`ReferenceError`の例外が発生します。
次の例では、どのスコープにも存在しない`xyz`を参照しているため、`ReferenceError`の例外が発生します。

```js
{
    // OUTERブロックスコープ
    {
        // INNERブロックスコープ
        console.log(xyz); // => ReferenceError: xyz is not defined
    }
}
```

このときも、現在のスコープ（変数を参照する式が書かれているスコープ）から外側のスコープへと順番に変数が定義されているかを確認します。しかし、どのスコープにも変数`xyz`は定義されていないため、`ReferenceError`の例外が発生します。つまり次のようなステップで参照したい変数を探索しています。

1. INNERブロックスコープに変数`xyz`があるかを確認 => ない
2. ひとつ外側のOUTERブロックスコープに変数`xyz`があるかを確認 => ない
3. 一番外側のスコープにも変数`xyz`は定義されていない => `ReferenceError`が発生

この内側から外側のスコープへと順番に変数が定義されているか探す仕組みのことを**スコープチェーン**と呼びます。

内側と外側のスコープ両方に同じ名前の変数が定義されている場合もスコープチェーンの仕組みで解決できます。
次のコードでは、内側のINNERブロックスコープと外側のOUTERブロックスコープに同じ名前の変数`x`が定義されています。
スコープチェーンの仕組みより、現在のスコープに定義されている変数`x`を優先的に参照します。

```js
{
    // OUTERブロックスコープ
    const x = "outer";
    {
        // INNERブロックスコープ
        const x = "inner";
        // 現在のスコープ(INNERブロックスコープ)にある`x`を参照する
        console.log(x); // => "inner"
    }
    // 現在のスコープ(OUTERブロックスコープ)にある`x`を参照する
    console.log(x); // => "outer"
}
```

このようにスコープは階層的な構造となっており、その際にどの変数が参照できるかはスコープチェーンによって解決されています。

## グローバルスコープ

今までコードをプログラム直下に書いていましたが、ここにも暗黙的な**グローバルスコープ**（大域スコープ）と呼ばれるスコープが存在します。
グローバルスコープとは名前のとおりもっとも外側にあるスコープで、プログラム実行時に暗黙的に作成されます。

```js
// プログラム直下はグローバルスコープ
const x = "x";
console.log(x);
```

グローバルスコープに定義した変数は**グローバル変数**と呼ばれ、グローバル変数はあらゆるスコープから参照できる変数となります。
なぜなら、スコープチェーンの仕組みにより、最終的にもっとも外側のグローバルスコープに定義されている変数を参照できるためです。

```js
// グローバル変数はどのスコープからも参照できる
const globalVariable = "グローバル";

{   
    // ブロックスコープ内には該当する変数が定義されてない -> 外側のスコープへ
    console.log(globalVariable); // => "グローバル"
}
function fn() {
    // 関数ブロックスコープ内には該当する変数が定義されてない -> 外側のスコープへ
    console.log(globalVariable); // => "グローバル"
}
fn();
```

<!-- textlint-disable preset-ja-technical-writing/sentence-length -->

グローバルスコープには自分で定義したグローバル変数以外に、プログラム実行時に自動的に定義されるビルトインオブジェクトがあります。
ビルトインオブジェクトには大きく分けて2種類のものがあります。
1つ目はECMAScript仕様が定義する`undefined`のような変数（「[undefinedはリテラルではない][]」を参照）や`isNaN`のような関数、`Array`や`RegExp`などのコンストラクタ関数です。もう一方は実行環境（ブラウザやNode.jsなど）が定義するオブジェクトで`document`や`module`などがあります。
どちらもグローバルスコープに自動的に定義されているという点で大きな使い分けはないため、この章ではどちらも**ビルトインオブジェクト**と呼ぶことにします。

<!-- Notes: global objectとbuilt-in object

- global object: https://tc39.github.io/ecma262/#sec-global-object
    - `global`でアクセスできる予定 https://github.com/tc39/proposal-global
    - Arrayなどもglobal objectのプロパティの一種
- builtin object: https://tc39.github.io/ecma262/#sec-built-in-object
    - ECMAScriptの定義したものと実装が加えたオブジェクトをまとめた用語
- 仕様どおりの定義で言えば、紹介してる`undefined`などはあくまでglobal objectのプロパティ
- `global`を使ってプロパティとしてアクセスする方法は言及していないので省略している

 -->

<!-- textlint-enable preset-ja-technical-writing/sentence-length -->

ビルトインオブジェクトは、プログラム開始時にグローバルスコープへ自動的に定義されているためどのスコープからも参照できます。

```js
// ビルトインオブジェクトは実行環境が自動的に定義している
// どこのスコープから参照してもReferenceErrorにはならない
console.log(undefined); // => undefined
console.log(Array); // => Array
```

自分で定義したグローバル変数とビルトインオブジェクトでは、グローバル変数が優先して参照されます。
つまり次のようにビルトインオブジェクト同じ名前の変数を定義すると、定義した変数が参照されます。

```js
// ビルトインオブジェクトのArray
console.log(Array); // => Array
// "Array"という名前の変数を定義
const Array = 1;
// 自分で定義した変数がビルトインオブジェクトより優先される
console.log(Array); // => 1
```

ビルトインオブジェクトと同じ名前の変数を定義したことにより、ビルトインオブジェクトを参照できなくなる問題は**変数の隠蔽**（shadowing）とも呼ばれます。
この問題を回避する方法としては、むやみにグローバルスコープへ変数を定義しないことです。グローバルスコープでビルトインオブジェクトと名前が衝突するとすべてのスコープへ影響を与えますが、関数のスコープ内ではその関数の中だけの影響範囲はとどまります。

ビルトインオブジェクトと同じ名前を避けることは難しいです。なぜならビルトインオブジェクトは実行環境（ブラウザやNode.jsなど）がそれぞれ独自に定義したものも多く存在します。そのため、関数などを活用し小さなスコープを中心にしてプログラムを書くことで、ビルトインオブジェクトと同じ名前の変数があっても影響範囲が限定的な状態にすることが望ましいです。

## [コラム] 変数を参照できる範囲を小さくする

グローバル変数に限らず、特定の変数を参照できる範囲を小さくすることはよいことです。
なぜなら、現在のスコープの変数を参照するつもりがグローバル変数を参照したり、その逆も起きることがあるからです。
あらゆる変数がグローバルスコープにあると、どこでその変数が参照されているのかを把握できなくなります。
これを避けるシンプルな考え方は、変数はできるだけ利用する近くのスコープ内に定義するということです。

次のコードでは、`doHeavyTask`関数の実行時間を計測しようとしています。
`Date.now`メソッドは現在の時刻をミリ秒にして返す関数で、**実行後の時刻**から**実行前の時刻**を引くことで間に行われた処理の実行時間を得ることができます。

```js
const startTime = Date.now();
doHeavyTask();
const endTime = Date.now();
console.log(`実行時間は${endTime - start}ミリ秒`);
```

このコードでは、計測処理以外で利用しない`startTime`と`endTime`という変数がグローバルスコープに定義されています。
プログラム全体が短い場合はあまり問題になりませんが、プログラムが長くなっていくにつれ影響の範囲が広がっていきます。
この2つの変数を参照できる範囲を小さくする簡単な方法はこの実行時間を計測する処理を関数にすることです。

```js
// 実行時間を計測したい関数を引数に渡す
const measureTask = (taskFn) => {
    const startTime = Date.now();
    taskFn();
    const endTime = Date.now();
    console.log(`実行時間は${endTime - start}ミリ秒`);
};
measureTask(doHeavyTask);
```

これにより、`startTime`と`endTime`という変数を外側のスコープから参照できなくなりました。
また、実行時間を計測するという処理を関数にしたことで再利用できます。

これは単純なように見えますが、コードの量が増えていくにつれ、人が一度に把握できる量にも限界がやってきます。
そのため、人が一度に把握できる範囲のサイズに処理をまとめていくことが必要です。
この問題を解決するアプローチとして、変数の参照できる範囲を小さくすることや処理を関数にまとめるという手法がよく利用されます。

## 関数スコープとvarの巻き上げ

<!-- textlint-disable eslint -->

変数宣言には`var`、`let`、`const`が利用できます。
[変数と宣言][]の章において、letは「よりよい`var`」と紹介したように、`var`を改善する目的で導入された構文です。`const`は再代入できないという点以外は`let`と同じ動作になります。そのため、`let`が使える場合に`var`を使う理由はありませんが、既存のコードや既存のライブラリなどでは`var`が利用されている場面もあるため、`var`の動作を理解する必要があります。

まず最初に、`let`と`var`で共通する動作を見ていきます。
`let`と`var`どちらも、初期値を指定せずに宣言した変数の評価結果は暗黙的に`undefined`になります。
また、`let`と`var`どちらも、変数宣言をした後に値を代入できます。

次のコードでは、それぞれ初期値を持たない変数を**宣言した後**に参照すると、変数の評価結果は`undefined`となっています。

```js
let let_x;
var var_x;
// 宣言後にそれぞれの変数を参照すると`undefined`となる
console.log(let_x); // => undefined
console.log(var_x); // => undefined
// 宣言後に値を代入できる
let_x = "letのx";
var_x = "varのx";
```

次に、`let`と`var`で異なる動作を見ていきます。

`let`では、変数を**宣言する前**にその変数を参照すると`ReferenceError`となります。
次のコードでは、変数を宣言する前に、変数`x`を参照したため`ReferenceError`となっています。
エラーメッセージから、変数`x`が存在しないからエラーになっているのではなく、実際に宣言した行より前に参照したためエラーとなることが分かります。[^TDZ]

```js
console.log(x); // => ReferenceError: can't access lexical declaration `x' before initialization
let x = "letのx";
```

一方`var`では、変数を**宣言する前**にその変数を参照しても`undefined`となります。
次のコードは、変数を宣言する前に参照しているにもかかわらずエラーにはならず、変数`x`の評価結果は`undefiend`となります。

```js
// var宣言より前に参照してもエラーにならない
console.log(x); // => undefined
var x = "varのx";
```

このように`var`で宣言された変数が宣言前に参照でき、その値が`undefined`となる特殊な動きをしていることが分かります。

この`var`の振る舞いを理解するために、変数宣言が**宣言**と**代入**の2つの部分から構成されていると考えてみましょう。
`var`による変数宣言は、暗黙的に**宣言**部分がもっと近い関数またはグローバルスコープの先頭に巻き上げられ、**代入**部分はそのままの位置に残るという特殊な動作をします。

この動作により、変数`x`を参照するコードより前に変数`x`の宣言部分が移動し、変数`x`の評価結果は暗黙的に`undefined`となっています。
つまり、先ほどのコードは実際の実行時には、次のように解釈されて実行されていると考えられます。

```js
// 解釈されたコード
// スコープの先頭に宣言部分が巻き上げられる
var x;
console.log(x); // => undefined
// 変数への代入はそのままの位置に残る
x = "varのx";
console.log(x); // => "varのx"
```

さらに、`var`変数の宣言の巻き上げは、ブロックスコープを無視してもっと近い関数またはグローバルスコープに変数を紐付けます。
そのため、次のようにブロック`{}`で`var`による変数宣言を囲んでも、もっとも近い関数スコープである`fn`関数の直下に**宣言**部分が巻き上げられます。
（if文やfor文におけるブロックスコープも同様に無視されます）

```js
function fn() {
    // 内側のスコープにあるはずの変数`x`が参照できる
    console.log(x); // => undefined
    {
        var x = "varのx";
    }
    console.log(x); // => "varのx"
}
fn();
```

つまり、先ほどのコードは実際の実行時には、次のように解釈されて実行されていると考えられます。

```js
// 解釈されたコード
function fn() {
    // もっと近い関数スコープの先頭に宣言部分が巻き上げられる
    var x;
    console.log(x); // => undefined
    {
        // 変数への代入はそのままの位置に残る
        x = "varのx";
    }
    console.log(x); // => "varのx"
}
fn();
```

この変数の**宣言**部分がもっと近い関数またはグローバルスコープの先頭に移動しているように見える動作のことを変数の**巻き上げ**（hoisting）と呼びます。

このように`let`、`const`に対して`var`は異なった動作をしています。
`var`は巻き上げによりブロックスコープを無視して、宣言部分を自動的にスコープの先頭に移動します。
もっとも簡単な回避方法は`var`を使わないことですが、`var`を含んだコードではこの動作に気をつける必要があります。

<!-- textlint-enable eslint -->

## 関数宣言と巻き上げ {#function-declaration-hoisting}

<!-- textlint-disable eslint -->

`function`キーワードを使った関数宣言も`var`と同様に、もっと近い関数またはグローバルスコープの先頭に**巻き上げ**されます。
次のコードでは、実際に`hello`関数を宣言した行より前に関数を呼び出せます。

```js
// `hello`関数の宣言より前に呼び出せる
hello(); // => "Hello"

function hello(){
    return "Hello";
}
```

これは、関数宣言は**宣言**そのものであるため、`hello`関数そのものがスコープの先頭に巻き上げされます。
つまり、先ほどのコードは実際の実行時には、次のように解釈されて実行されていると考えられます。

```js
// 解釈されたコード
// `hello`関数の宣言が巻き上げされる
function hello(){
    return "Hello";
}

hello(); // => "Hello"
```

注意点として、`var`や`let`などで宣言された変数へ関数を代入した場合は`var`のルールで巻き上げされます。
そのため、`var`で変数へ関数を代入する関数式では、`hello`変数が巻き上げにより`undefined`となるため呼び出すことができません。（「[関数と宣言（関数式）][]」を参照）

```js
// `hello`変数は巻き上げされ、暗黙的に`undefined`となる
hello(); // => TypeError: hello is not a function

// `hello`変数へ関数を代入している
var hello = function(){
    return "Hello";
}
```

<!-- textlint-enable eslint -->

## クロージャー {#closure}

最後にこの章ではクロージャーと呼ばれる関数とスコープに関わる性質について見ていきます。
クロージャーとは「関数が外側のスコープにある変数への参照を保持できる」という関数がもつ性質のことです。

クロージャーは言葉で説明しただけでは分かりにくい性質です。
このセクションでは、次のクロージャを使ったコードがどのようにして動くのかを理解することを目標にします。

次の例では`createCounter`関数は、関数内で定義した`countUp`関数を返しています。
その返された`countUp`関数を`counter`変数を代入しています。この`counter`変数を実行するたびに1,2,3と1づつ増えた値を返しています。

さらに、もう一度`createCounter`関数を実行しその返り値を`newCounter`変数に代入します。
`newCounter`変数も実行するたびに1づつ増えていますが、`counter`変数とその値を共有しているわけではないことが分かります。

```js
// `countUp`関数を定義し返す関数
function createCounter() {
    let count = 0;
    // `countUp`関数は`count`変数を参照
    function countUp() {
        count = count + 1;
        return count;
    };
    return countUp;
}
// `counter`は`createCounter`が返した関数を参照
const counter = createCounter();
counter(); // => 1
counter(); // => 2
// 新しく`newCounter`を定義する
const newCounter = createCounter();
newCounter(); // => 1
newCounter(); // => 2
// `counter`と`newCounter`は別々の状態持っている
counter(); // => 3
newCounter(); // => 3
```

このように、まるで関数が状態（ここでは1づつ増える`count`という値）を持っているように振る舞える仕組みの背景にはクロージャがあります。
クロージャーを直感的には理解しにくいため、まずはクロージャを理解するために必要な「静的スコープ」と「メモリ管理の仕組み」についてを見ていきます。

### 静的スコープ {#static-scope}

クロージャーを理解するために、今まで意識してことなかったスコープの性質について見ていきます。
JavaScriptのスコープでは、どの識別子がどの変数を参照しているかは静的に決定されるという性質を持ちます。
つまり、コードを実行する前にどの識別子がどの変数を参照しているかが分かるということです。

次のような例を見てみます。
関数`printX`内から変数`x`を参照していますが、変数`x`はグローバルスコープと関数`run`の中にそれぞれ定義されています。
結論からいえば、`printX`関数の実行結果は常に`10`となります。

```js
const x = 10; // ＊1

function printX() {
    // この識別子`x`は常に ＊1 の変数`x`を参照する
    console.log(x); // => 10
}

function run() {
    const x = 20; // ＊2
    printX(); // 常に10が出力される
}

run();
```

スコープチェーンの仕組みを思い出すと、この識別子`x`は次のように名前解決されグローバルスコープの変数`x`を参照することが分かります。

1. `printX`の関数スコープに`x`が定義されていない
2. ひとつ外側のスコープ（グローバルスコープ）かを確認する
3. ひとつ外側のスコープに`const x = 10;`が定義されているのでこれを参照する

つまり、`printX`関数内に書かれた`x`という識別子は、`run`関数を実行されるかは関係なく、静的に＊1で定義された変数`x`を参照することが決定されます。
このように、静的にどの識別子がどの変数を参照しているかが決定する性質を**静的スコープ**と呼びます。

### [コラム] 動的スコープ {#dynamic-scope}

多くの言語は静的スコープですが、BashやPerl4などは呼び出し元によってどの変数を参照するかが変わる仕組みを持っています。

次のコードは、もしJavaScriptが呼び出し元によって参照する変数が変わる場合の結果を表した擬似的なコードです。
JavaScriptは静的スコープであるので、実際には次のような結果にはなりませんが、
識別子`x`が呼び出し元のスコープを参照する仕組みである場合には次のような結果になります。

```js
// JavaScriptが静的スコープでないとした場合の擬似的なコード例
const x = 10; // ＊1

function printX() {
    // この識別子`x`は呼び出し元によってどの変数`x`を参照するかが変わる
    console.log(x);
}

function run() {
    const x = 20;
    // 呼び出し元で変数`x`を定義している
    printX();
}

printX(); // ここでは 10 が出力される
run(); // ここでは 20 が出力される
```

このように呼び出し方によって動的に参照する変数が変わる仕組みのことを**動的スコープ**と呼びます。

JavaScriptは静的スコープですが、`this`といった特定のキーワードは動的スコープのように、
呼び出し元によって参照先が変わるという挙動します。`this`については次章で解説します。

## メモリ管理の仕組み {#memory-management}

ほとんどのプログラミング言語では使わなくなった変数やデータを解放することで、メモリ上のデータが溢れない仕組みを持っています。
なぜなら、変数や関数を定義するとその定義されたデータはメモリ上に確保されますが、ハードウェアのメモリは有限であるためです。
JavaScriptエンジンでは不要となったデータを自動で解放します。この自動的に不要なデータを回収し解放する仕組みのことをガーベジコレクションと呼びます。

JavaScriptでは、手動でメモリを解放するコードを書く必要がないためガベージコレクションを意識しなくても動くコードは書くことができます。
しかし、その不要になったタイミングとはどのようなタイミングかを理解することは、スコープやクロージャーにも関係するため大切です。

この必要なタイミングというのは、「そのデータがどこからも参照されることがなくなった」タイミングとなります。
具体的な例を見てみましょう。
変数`x`に新しい値を代入した際に、もともと変数`x`が参照していた`"before text"`という値はどこからも参照されなくなっています。
つまり、参照されなくなった時点で不要になったデータと判断されます。その後、任意のタイミングでガーベジコレクションによって回収されメモリ上から解放されます。（JavaScriptではガベージコレクションを明示的に呼び出す方法は用意されていないため、実際に解放されるタイミングはJavaScriptエンジンの実装に依存します。）

```js
let x = "before text";
// 変数`x`に新しい値を代入する
x = "after text";
// この時"before text"という値はどこからも参照されなくなる
// => ガーベッジコレクションによってメモリ上から自動的に解放される
``` 

次にこのガベージコレクションと関数の関係性について考えてみましょう。
よくある誤解として「関数の中で定義した値は、その関数が実行し終了したら解放される」という誤解があります。
関数の中で定義された値は、その関数の実行が終了した時点では必ずしも解放されるわけではありません。

具体的に、関数の実行が終了した際に解放される場合と解放されない場合の例を見ていきます。

まずは、関数の実行が終了した際に解放される値の例です。
次のコードでは、`printX`関数の中で変数`x`を定義しています。
この変数`x`とその値は、`printX`関数が実行されるたびに定義され、実行終了後にどこからも参照されなくなります。
どこからも参照できなくなったものは、ガベージコレクションによって回収されメモリ上から解放されます。

```js
function printX() {
    const x = "x";
    console.log(x); // => "x";
}

printX();
// この時点で`x`を参照するものはなくなる => 解放される
```

次に、関数の実行が終了しても解放されない値の例です。
次のコードでは、`createArray`関数の中で定義された変数`tempArray`は、`run`関数の返り値となっています。
この、関数で定義された変数`tempArray`は返り値として、別の変数`array`に代入されています。
つまり、`tempArray`の値である配列オブジェクトは`createArray`関数の実行終了後も別のスコープから参照され続けています。
ひとつでも参照されているならば、その値は自動的に解放されることはありません。

```js
function createArray() {
    const tempArray = [1, 2, 3];
    return tempArray;
}
const array = createArray();
console.log(x); // => [1, 2, 3]
// 変数`array`が`[1, 2, 3]`という値を参照してる => 解放されない
```

つまり、関数の実行終了と値が解放されるかどうかは直接関係ないことが分かります。
その値がメモリ上から解放されるかどうかはあくまで、その値を参照している変数があるかどうかによって決定されます。

### クロージャーがなぜ動くのか

ここまでで「静的スコープ」と「メモリ管理の仕組み」について説明してきました。

- 静的スコープ: ある変数がどの値を参照するかは静的に決まる
- メモリ管理の仕組み: 値は参照されなくなったらガーベジコレクションによって解放されるという

クロージャーとはこの２つの仕組みを利用して、関数内から特定の変数を参照し続けることで関数が状態をもつことができる仕組みのことを言います。
<!-- クロージャーは関数閉包と呼ばれることがありますが、関数の内側に変数を閉じ込めることで、まるで関数が状態（変数）を持っているように見えます。 -->

最初にクロージャーの例として紹介した`createCounter`関数の例を改めて見てみましょう。

```js
const createCounter = () => {
    let count = 0;
    return function countUp() {
        // `countUp`関数は外のスコープの変数`count`を参照している
        // これがクロージャーと呼ばれる
        count = count + 1;
        return count;
    };
};
// createCounter()の実行結果は、内側で定義されていた`countUp`関数
const counter = createCounter();
// counter関数の実行結果は`count`の評価結果
counter(); // => 1
counter(); // => 2
```

コードが実行される順番に見ていきましょう。

まずは、`counter`変数についてです。

1. `counter`変数の初期値は`createCounter`関数の実行結果

`createCounter`関数は次のことを行っています。

1. 新しく`count`変数を定義し初期値を0となる
2. 新しく`countUp`関数を定義し返す

`countUp`関数は次のことを行っています。

1. `createCounter`が定義した`count`変数の値を1増加させる
2. `count`変数の評価結果を返す

`countUp`関数は（`countUp`関数から見ると）外側のスコープにある`count`変数を参照しています。
また、`counter`変数は`createCounter`関数の返り値である`countUp`関数を参照しています。
つまり、`counter`変数は間接的に`count`変数を参照しているため、`count`変数は自動的に解放されません。

<!-- 参照の方向の図 -->

> `counter` -> `countUp` -> `count`

このように`count`変数が自動解放されずに保持できているのは「（`countUp`）関数が外側のスコープにある（`count`）変数への参照を保持できる」ためです。
このような性質のことをクロージャー(関数閉包）と呼びます。クロージャーは静的スコープと変数は参照され続けていれば値は保持されるという2つの性質によって成り立っています。JavaScriptの関数は常にこの2つの性質をもっています。そのため、ある意味ではすべての関数がクロージャーとなりますが、ここでは関数が特定の変数を参照することで関数が状態をもっていることを指すことにします。

先ほどの例では`createCounter`関数を実行するたびに、それぞれ`count`と`CountUp`関数が定義しています。そのため、`createCounter`関数の実行するとそれぞれ別々の`countUp`関数が定義され、別々の`count`変数を参照しています。

次のように`createCounter`関数を複数回呼び出してみると、別々の状態を持っていることが確認できます。

```js
const createCounter = () => {
    let count = 0;
    return function countUp() {
        // 変数`count`を参照し続けている
        count = count + 1;
        return count;
    };
};
// countUpとnewCountUpはそれぞれ別のcountUp関数(内側にあるのも別のcount変数)
const countUp = createCounter();
const newCountUp = createCounter();
// 参照してる関数(オブジェクト)は別であるため===は一致しない
console.log(countUp === newCountUp);// false
// それぞれの状態も別となる
countUp(); // => 1
newCountUp(); // => 1
```

### クロージャーの用途 {#closure-usecase}

クロージャーはさまざまな用途に利用されますが、次のような用途で利用されることが多いです。

- 関数に状態を持たせる手段として
- 外から参照できない変数を定義する手段として
- グローバル変数を減らす手段として
- 高階関数の一部部分として

これらはクロージャーの特徴でもあるので、同時に使われることがあります。

たとえば次の例では、`privateCount`という変数を関数の中に定義していますが、
外からはその変数を直接参照はできません。言い換えると外から直接参照して値を変更することはできません。
外から参照する必要がない値をクロージャーとなる関数に閉じ込めることは、言い換えるとグローバルに定義する変数を減らすことができます。

```js
const createCounter = () => {
    // 外のスコープから`privateCount`を直接参照できない
    const privateCount = 0;
    return () => {
        privateCount++;
        return `${privateCount}回目`;
    };
};
const counter = createCounter();
counter(); // => "1回目"
counter(); // => "2回目"
```

また、関数を返す関数のことを高階関数と呼びますが、クロージャの性質を使うことで次のように`n`より大きいかを判定する高階関数を作れます。
最初から`gereterThan5`という関数を定義すればよいのですが、高階関数を使うことで文字列などの値と同じように関数を値としてやり取りできます。

```js
function greaterThan(n) {
    return function(m) {
        return m > n; 
    };
}
const gereterThan5 = greaterThan(5);
gereterThan42(5); // => false
gereterThan42(6); // => true
```

### [コラム] 状態をもつ関数オブジェクト {#closure-vs-function-object}

JavaScriptでは関数はオブジェクトの一種です。オブジェクトであるということは直接プロパティに値を入れることが可能です。
つまり、状態を関数をもつ方法として、次のように直接関数に値を代入するという手段をとることができます。

```js
function countUp() {
    // countプロパティを参照して変更する
    countUp.count = countUp.count + 1;
    return countUp.count;
};
// 関数オブジェクトにプロパティとし値を代入する
countUp.count = 0;
// 呼び出すことにcountが更新される
countUp(); // => 1
countUp(); // => 2
```

しかし、この方法は推奨されていません。理由としては、外から直接`count`プロパティが変更できるためです。
関数オブジェクトのプロパティは外からも参照でき、またそのプロパティ値を変更できます。
その値を外から見えないように隠しているつもりなら、それを強制できるクロージャーが有効です。

```js
function countUp() {
    // countプロパティを参照して変更する
    countUp.count = countUp.count + 1;
    return countUp.count;
};
countUp.count = 0;
// 呼び出すことにcountが更新される
countUp(); // => 1
// 直接値を変更できてしまう
countUp.count = 10;
countUp(); // => 11
```

### クロージャーのまとめ {#closure-conclusion}

クロージャーは、変数が参照する値は静的に決まる静的スコープという性質と変数は参照され続けていれば値は保持されるという2つの性質によって成り立っています。
JavaScriptでは、関数を短く定義できるArrow Functionや高階関数であるメソッドなどクロージャーを自然と利用しやすい環境があります。
関数を理解する上ではクロージャーを理解することは大切です。


[変数と宣言]: ../variables/README.md
[変数と宣言#let]: ../variables/README.md#let
[関数と宣言（関数式）]: ../function-declaration/README.md#function-expression
[文と式]: ../statement-expression/README.md
[undefinedはリテラルではない]: ../data-type/README.md##undefined-not-literal
[^TDZ]: この仕組みはTemporal Dead Zoneと呼ばれます。
