---
author: azu
---

# 関数とスコープ

定義された関数はそれぞれのスコープを持っています。スコープとは変数や関数の引数などを参照できる範囲を決めるものです。
JavaScriptでは、新しい関数を定義するとその関数に紐付けられた新しいスコープを作成します。関数を定義するということは処理をまとめるというだけではなく、変数が有効な範囲を決める新しいスコープを作っているといえます。

スコープの仕組みを理解することは関数をより深く理解することにつながります。なぜなら関数とスコープは密接な関係を持っているためです。
この章では関数とスコープの関係を中心に、スコープとはどのような働きをしていて、スコープ内では変数の名前から値がどのように取得されているのかを見ていきます。

JavaScriptのスコープは、ES2015において直感的に理解しやすい仕組みが整備されました。
基本的にはES2015以降の仕組みを理解していればコードを書く場合には問題ありません。

しかし、既存のコードを理解するためには、ES2015より前に決められた古い仕組みについても知る必要があります。
なぜなら、既存のコードは古い仕組みを使って書かれていることもあるためです。
また、JavaScriptでは古い仕組みと新しい仕組みを混在して書くことができます。
古い仕組みによるスコープは直感的でない挙動も多いため、コラムで補足していきます。

## スコープとは

スコープとは変数の名前や関数などの参照できる範囲を決めるものです。
スコープの中で定義された変数はスコープ内でのみ参照でき、スコープの外側からは参照できません。

身近なスコープの例として関数によるスコープを見ていきます。
次のコードには、`fn`関数のブロック（`{`と`}`）内で変数`x`を定義しています。
この変数`x`は`fn`関数のスコープに定義されているため、`fn`関数の内側では参照できます。
一方、`fn`関数の外側から変数`x`は参照できないため`ReferenceError`をなげます。

```js
function fn() {
    const x = 1;
    // fn関数のスコープ内から`x`は参照できる
    console.log(x); // => 1
}
fn();
// fn関数のスコープ外から`x`は参照できないためエラー
console.log(x); // => ReferenceError: x is not defined
```

このコードを見て分かるように、変数`x`は`fn`関数のスコープに紐付けて定義されます。
そのため、変数`x`は`fn`関数のスコープ内でのみ参照できます。

関数は**仮引数**をもつことができますが、仮引数は関数のスコープに紐付けて定義します。
そのため、仮引数はその関数の中でのみ参照が可能で、関数の外からは参照できません。

<!-- Note: 関数の仮引数はvarで宣言されたものと同じ扱い

関数の宣言
- Set F.[[FormalParameters]] to ParameterList.
- https://tc39.github.io/ecma262/#sec-functioninitialize
- function objectの[[Environment]]ではなく、[[FormalParameters]]に代入される
- 仮引数は関数のスコープではなくfunction objectに紐づく

関数の初期化処理
- https://tc39.github.io/ecma262/#sec-functiondeclarationinstantiation
- [[FormalParameters]]は初期化時に`varEnv`に対して代入される
- つまり、仮引数はvarで宣言しているのと同じになる
- スコープという意味では内側のみから参照でき、外からは参照できないという点で同じ

 -->

```js
function fn(arg) {
    // fn関数のスコープ内から仮引数`arg`は参照できる
    console.log(arg); // => 1
}
fn(1);
// fn関数のスコープ外から`arg`は参照できないためエラー
console.log(arg); // => ReferenceError: arg is not defined
```

この関数によるスコープのことを**関数スコープ**と呼びます。

[変数と宣言][]の章にて、`let`や`const`は同じスコープ内に同じ名前の変数を二重に定義できないという話をしました。
これは、各スコープには同じ名前の変数は1つしか宣言できないためです。（`var`と`function`による関数宣言は例外的に可能です）

[import, identifier-duplicated-invalid](./src/identifier-duplicated-invalid.js)

一方、スコープが異なれば同じ名前で変数を宣言できます。
次の例では、`fnA`関数と`fnB`関数という異なるスコープで、それぞれ変数`x`を定義できていることが分かります。

```js
// 異なる関数のスコープには同じ"x"を定義できる
function fnA() {
    let x;
}
function fnB() {
    let x;
}
```

このように、スコープが異なれば同じ名前の変数を定義できます。
スコープの仕組みがないと、グローバルな空間な一意な変数名を考える必要があります。
スコープがあることで適切な名前の変数を定義できるようになるため、スコープの役割は重要です。

## ブロックスコープ

`{`と`}`で囲んだ範囲をブロックと呼びます。（「[文と式][]」の章を参照）
ブロックもスコープを作成します。
ブロック内で宣言された変数は、スコープ内でのみ参照でき、スコープの外側からは参照できません。

```js
// ブロック内で定義した変数はスコープ内でのみ参照できる
{
    const x = 1;
    console.log(x); // => 1
}
// スコープの外から`x`を参照できないためエラー
console.log(x); // => ReferenceError: x is not defined
```

ブロックによるスコープのことを**ブロックスコープ**と呼びます。

<!-- Notes: ブロックスコープと仕様

- ブロック`{}`は新しい[NewDeclarativeEnvironment](https://tc39.github.io/ecma262/#sec-newdeclarativeenvironment "NewDeclarativeEnvironment")を作成する
- つまり、新しいLexicalEnviromentというスコープを作成している
- https://tc39.github.io/ecma262/#sec-block-runtime-semantics-evaluation
- そして評価する際に、そのブロック内に宣言されている変数をスコープに対して紐付けている
- https://tc39.github.io/ecma262/#sec-blockdeclarationinstantiation

 -->

if文やwhile文などもブロックスコープを作成します。
単独のブロックと同じく、ブロックの中で宣言した変数は外から参照できません。

```js
// if文のブロック内で定義した変数はブロックスコープの中でのみ参照できる
if (true) {
    const x = "inner";
    console.log(x); // => "inner"
}
console.log(x); // => ReferenceError: x is not defined
```

for文は、ループごとに新しいブロックスコープを作成します。
このことは「各スコープには同じ名前の変数は1つしか宣言できない」のルールを考えてみると分かりやすいです。
次のコードでは、ループ毎に`const`で`element`変数を定義していますが、エラーなく定義できています。
これは、ループ毎に別々のブロックスコープが作成され、変数の宣言もそれぞれ別々のスコープで行われるためです。

```js
const array = [1, 2, 3, 4, 5];
// ループごとに新しいブロックスコープを作成する
for (const element of array) {
    // forのブロックスコープの中でのみ`element`を参照できる
    console.log(element);
}
// ループの外からはブロックスコープ内の変数は参照できない
console.log(element); // => ReferenceError: element is not defined
```

<!-- Note: forとブロックスコープの仕様

- 仕様ではforをIterateする際に`CreatePerIterationEnvironment`で新しい NewDeclarativeEnvironmentを作成している
- [9. Variables and scoping](http://exploringjs.com/es6/ch_variables.html#sec_let-const-loop-heads)
- [ECMAScript 2015 Language Specification – ECMA-262 6th Edition](http://www.ecma-international.org/ecma-262/6.0/#sec-createperiterationenvironment)

 -->

## スコープチェーン

関数やブロックはネスト（入れ子）して書けますが、同様にスコープもネストできます。
次のコードではブロックの中にブロックを書いています。
このとき外側のブロックスコープのことを`OUTER`、内側のブロックスコープのことを`INNER`と呼ぶことにします。

```js
{
    // OUTERブロックスコープ
    {
        // INNERブロックスコープ
    }
}
```

スコープがネストしている場合に、内側のスコープから外側のスコープにある変数を参照できます。
次のコードでは、内側のINNERブロックスコープから外側のOUTERブロックスコープに定義されている変数`x`を参照できます。
これは、ブロックスコープに限らず関数スコープでも同様です。

```js
{
    // OUTERブロックスコープ
    const x = "x";
    {
        // INNERブロックスコープからOUTERブロックスコープの変数を参照できる
        console.log(x); // => "x"
    }
}
```

このとき、現在のスコープ（変数を参照する式が書かれているスコープ）から外側のスコープへと順番に変数が定義されているかを確認します。このとき、内側のINNERブロックスコープには変数`x`はありませんが外側のOUTERブロックスコープに変数`x`が定義されているため参照できます。つまり次のようなステップで参照したい変数を探索しています。

1. INNERブロックスコープに変数`x`があるかを確認 => ない
2. ひとつ外側のOUTERブロックスコープに変数`x`があるかを確認 => ある

一方、現在のスコープも含めどの外側のスコープに該当する変数が定義されていない場合は、`ReferenceError`の例外が発生します。
次の例では、どのスコープにも存在しない`xyz`を参照しているため、`ReferenceError`の例外が発生します。

```js
{
    // OUTERブロックスコープ
    {
        // INNERブロックスコープ
        console.log(xyz); // => ReferenceError: xyz is not defined
    }
}
```

このときも、現在のスコープ（変数を参照する式が書かれているスコープ）から外側のスコープへと順番に変数が定義されているかを確認します。しかし、どのスコープにも変数`xyz`は定義されていないため、`ReferenceError`の例外が発生します。つまり次のようなステップで参照したい変数を探索しています。

1. INNERブロックスコープに変数`xyz`があるかを確認 => ない
2. ひとつ外側のOUTERブロックスコープに変数`xyz`があるかを確認 => ない
3. 一番外側のスコープにも変数`xyz`は定義されていない => `ReferenceError`が発生

この内側から外側のスコープへと順番に変数が定義されているか探す仕組みのことを**スコープチェーン**と呼びます。

内側と外側のスコープ両方に同じ名前の変数が定義されている場合もスコープチェーンの仕組みで解決できます。
次のコードでは、内側のINNERブロックスコープと外側のOUTERブロックスコープに同じ名前の変数`x`が定義されています。
スコープチェーンの仕組みより、現在のスコープに定義されている変数`x`を優先的に参照します。

```js
{
    // OUTERブロックスコープ
    const x = "outer";
    {
        // INNERブロックスコープ
        const x = "inner";
        // 現在のスコープ(INNERブロックスコープ)にある`x`を参照する
        console.log(x); // => "inner"
    }
    // 現在のスコープ(OUTERブロックスコープ)にある`x`を参照する
    console.log(x); // => "outer"
}
```

このようにスコープは階層的な構造となっており、その際にどの変数が参照できるかはスコープチェーンによって解決されています。

## グローバルスコープ

今までコードをプログラム直下に書いていましたが、ここにも暗黙的な**グローバルスコープ**（大域スコープ）と呼ばれるスコープが存在します。
グローバルスコープとは名前のとおりもっとも外側にあるスコープで、プログラム実行時に暗黙的に作成されます。

```js
// プログラム直下はグローバルスコープ
const x = "x";
console.log(x);
```

グローバルスコープに定義した変数は**グローバル変数**と呼ばれ、グローバル変数はあらゆるスコープから参照できる変数となります。
なぜなら、スコープチェーンの仕組みにより、最終的にもっとも外側のグローバルスコープに定義されている変数を参照できるためです。

```js
// グローバル変数はどのスコープからも参照できる
const globalVariable = "グローバル";

{   
    // ブロックスコープ内には該当する変数が定義されてない -> 外側のスコープへ
    console.log(globalVariable); // => "グローバル"
}
function fn() {
    // 関数ブロックスコープ内には該当する変数が定義されてない -> 外側のスコープへ
    console.log(globalVariable); // => "グローバル"
}
fn();
```

<!-- textlint-disable preset-ja-technical-writing/sentence-length -->

グローバルスコープには自分で定義したグローバル変数以外に、プログラム実行時に自動的に定義されるビルトインオブジェクトがあります。
ビルトインオブジェクトには大きく分けて2種類のものがあります。
1つ目はECMAScript仕様が定義する`undefined`のような変数（「[undefinedはリテラルではない][]」を参照）や`isNaN`のような関数、`Array`や`RegExp`などのコンストラクタ関数です。もう一方は実行環境（ブラウザやNode.jsなど）が定義するオブジェクトで`document`や`module`などがあります。
どちらもグローバルスコープに自動的に定義されているという点で大きな使い分けはないため、この章ではどちらも**ビルトインオブジェクト**と呼ぶことにします。

<!-- Notes: global objectとbuilt-in object

- global object: https://tc39.github.io/ecma262/#sec-global-object
    - `global`でアクセスできる予定 https://github.com/tc39/proposal-global
    - Arrayなどもglobal objectのプロパティの一種
- builtin object: https://tc39.github.io/ecma262/#sec-built-in-object
    - ECMAScriptの定義したものと実装が加えたオブジェクトをまとめた用語
- 仕様どおりの定義で言えば、紹介してる`undefined`などはあくまでglobal objectのプロパティ
- `global`を使ってプロパティとしてアクセスする方法は言及していないので省略している

 -->

<!-- textlint-enable preset-ja-technical-writing/sentence-length -->

ビルトインオブジェクトは、プログラム開始時にグローバルスコープへ自動的に定義されているためどのスコープからも参照できます。

```js
// ビルトインオブジェクトは実行環境が自動的に定義している
// どこのスコープから参照してもReferenceErrorにはならない
console.log(undefined); // => undefined
console.log(Array); // => Array
```

自分で定義したグローバル変数とビルトインオブジェクトでは、グローバル変数が優先して参照されます。
つまり次のようにビルトインオブジェクト同じ名前の変数を定義すると、定義した変数が参照されます。

```js
// ビルトインオブジェクトのArray
console.log(Array); // => Array
// "Array"という名前の変数を定義
const Array = 1;
// 自分で定義した変数がビルトインオブジェクトより優先される
console.log(Array); // => 1
```

ビルトインオブジェクトと同じ名前の変数を定義したことにより、ビルトインオブジェクトを参照できなくなる問題は**変数の隠蔽**（shadowing）とも呼ばれます。
この問題を回避する方法としては、むやみにグローバルスコープへ変数を定義しないことです。グローバルスコープでビルトインオブジェクトと名前が衝突するとすべてのスコープへ影響を与えますが、関数のスコープ内ではその関数の中だけの影響範囲はとどまります。

ビルトインオブジェクトと同じ名前を避けることは難しいです。なぜならビルトインオブジェクトは実行環境（ブラウザやNode.jsなど）がそれぞれ独自に定義したものも多く存在します。そのため、関数などを活用し小さなスコープを中心にしてプログラムを書くことで、ビルトインオブジェクトと同じ名前の変数があっても影響範囲が限定的な状態にすることが望ましいです。

## [コラム] 変数を参照できる範囲を小さくする

グローバル変数に限らず、特定の変数を参照できる範囲を小さくすることはよいことです。
なぜなら、現在のスコープの変数を参照するつもりがグローバル変数を参照したり、その逆も起きることがあるからです。
あらゆる変数がグローバルスコープにあると、どこでその変数が参照されているのかを把握できなくなります。
これを避けるシンプルな考え方は、変数はできるだけ利用する近くのスコープ内に定義するということです。

次のコードでは、`doHeavyTask`関数の実行時間を計測しようとしています。
`Date.now`メソッドは現在の時刻をミリ秒にして返す関数で、**実行後の時刻**から**実行前の時刻**を引くことで間に行われた処理の実行時間を得ることができます。

```js
const startTime = Date.now();
doHeavyTask();
const endTime = Date.now();
console.log(`実行時間は${endTime - start}ミリ秒`);
```

このコードでは、計測処理以外で利用しない`startTime`と`endTime`という変数がグローバルスコープに定義されています。
プログラム全体が短い場合はあまり問題になりませんが、プログラムが長くなっていくにつれ影響の範囲が広がっていきます。
この2つの変数を参照できる範囲を小さくする簡単な方法はこの実行時間を計測する処理を関数にすることです。

```js
// 実行時間を計測したい関数を引数に渡す
const measureTask = (taskFn) => {
    const startTime = Date.now();
    taskFn();
    const endTime = Date.now();
    console.log(`実行時間は${endTime - start}ミリ秒`);
};
measureTask(doHeavyTask);
```

これにより、`startTime`と`endTime`という変数を外側のスコープから参照できなくなりました。
また、実行時間を計測するという処理を関数にしたことで再利用できます。

これは単純なように見えますが、コードの量が増えていくにつれ、人が一度に把握できる量にも限界がやってきます。
そのため、人が一度に把握できる範囲のサイズに処理をまとめていくことが必要です。
この問題を解決するアプローチとして、変数の参照できる範囲を小さくすることや処理を関数にまとめるという手法がよく利用されます。

## 関数スコープとvarの巻き上げ

<!-- textlint-disable eslint -->

変数宣言には`var`、`let`、`const`が利用できます。
[変数と宣言][]の章において、letは「よりよい`var`」と紹介したように、`var`を改善する目的で導入された構文です。`const`は再代入できないという点以外は`let`と同じ動作になります。そのため、`let`が使える場合に`var`を使う理由はありませんが、既存のコードや既存のライブラリなどでは`var`が利用されている場面もあるため、`var`の動作を理解する必要があります。

まず最初に、`let`と`var`で共通する動作を見ていきます。
`let`と`var`どちらも、初期値を指定せずに宣言した変数の評価結果は暗黙的に`undefined`になります。
また、`let`と`var`どちらも、変数宣言をした後に値を代入できます。

次のコードでは、それぞれ初期値を持たない変数を**宣言した後**に参照すると、変数の評価結果は`undefined`となっています。

```js
let let_x;
var var_x;
// 宣言後にそれぞれの変数を参照すると`undefined`となる
console.log(let_x); // => undefined
console.log(var_x); // => undefined
// 宣言後に値を代入できる
let_x = "letのx";
var_x = "varのx";
```

次に、`let`と`var`で異なる動作を見ていきます。

`let`では、変数を**宣言する前**にその変数を参照すると`ReferenceError`となります。
次のコードでは、変数を宣言する前に、変数`x`を参照したため`ReferenceError`となっています。
エラーメッセージから、変数`x`が存在しないからエラーになっているのではなく、実際に宣言した行より前に参照したためエラーとなることが分かります。[^TDZ]

```js
console.log(x); // => ReferenceError: can't access lexical declaration `x' before initialization
let x = "letのx";
```

一方`var`では、変数を**宣言する前**にその変数を参照しても`undefined`となります。
次のコードは、変数を宣言する前に参照しているにもかかわらずエラーにはならず、変数`x`の評価結果は`undefiend`となります。

```js
// var宣言より前に参照してもエラーにならない
console.log(x); // => undefined
var x = "varのx";
```

このように`var`で宣言された変数が宣言前に参照でき、その値が`undefined`となる特殊な動きをしていることが分かります。

この`var`の振る舞いを理解するために、変数宣言が**宣言**と**代入**の2つの部分から構成されていると考えてみましょう。
`var`による変数宣言は、暗黙的に**宣言**部分がもっと近い関数またはグローバルスコープの先頭に巻き上げられ、**代入**部分はそのままの位置に残るという特殊な動作をします。

この動作により、変数`x`を参照するコードより前に変数`x`の宣言部分が移動し、変数`x`の評価結果は暗黙的に`undefined`となっています。
つまり、先ほどのコードは実際の実行時には、次のように解釈されて実行されていると考えられます。

```js
// 解釈されたコード
// スコープの先頭に宣言部分が巻き上げられる
var x;
console.log(x); // => undefined
// 変数への代入はそのままの位置に残る
x = "varのx";
console.log(x); // => "varのx"
```

さらに、`var`変数の宣言の巻き上げは、ブロックスコープを無視してもっと近い関数またはグローバルスコープに変数を紐付けます。
そのため、次のようにブロック`{}`で`var`による変数宣言を囲んでも、もっとも近い関数スコープである`fn`関数の直下に**宣言**部分が巻き上げられます。
（if文やfor文におけるブロックスコープも同様に無視されます）

```js
function fn() {
    // 内側のスコープにあるはずの変数`x`が参照できる
    console.log(x); // => undefined
    {
        var x = "varのx";
    }
    console.log(x); // => "varのx"
}
fn();
```

つまり、先ほどのコードは実際の実行時には、次のように解釈されて実行されていると考えられます。

```js
// 解釈されたコード
function fn() {
    // もっと近い関数スコープの先頭に宣言部分が巻き上げられる
    var x;
    console.log(x); // => undefined
    {
        // 変数への代入はそのままの位置に残る
        x = "varのx";
    }
    console.log(x); // => "varのx"
}
fn();
```

この変数の**宣言**部分がもっと近い関数またはグローバルスコープの先頭に移動しているように見える動作のことを変数の**巻き上げ**（hoisting）と呼びます。

このように`let`、`const`に対して`var`は異なった動作をしています。
`var`は巻き上げによりブロックスコープを無視して、宣言部分を自動的にスコープの先頭に移動します。
もっとも簡単な回避方法は`var`を使わないことですが、`var`を含んだコードではこの動作に気をつける必要があります。

<!-- textlint-enable eslint -->

## 関数宣言と巻き上げ {#function-declaration-hoisting}

<!-- textlint-disable eslint -->

`function`キーワードを使った関数宣言も`var`と同様に、もっと近い関数またはグローバルスコープの先頭に**巻き上げ**されます。
次のコードでは、実際に`hello`関数を宣言した行より前に関数を呼び出せています。

```js
// `hello`関数の宣言より前に呼び出せる
hello(); // => "Hello"

function hello(){
    return "Hello";
}
```

これは、関数宣言は**宣言**そのものであるため、`hello`関数そのものがスコープの先頭に巻き上げされます。
つまり、先ほどのコードは実際の実行時には、次のように解釈されて実行されていると考えられます。

```js
// 解釈されたコード
// `hello`関数の宣言が巻き上げされる
function hello(){
    return "Hello";
}

hello(); // => "Hello"
```

注意点として、`var`や`let`などで宣言された変数へ関数を代入した場合は`var`のルールで巻き上げされます。
そのため、先ほどの`function`キーワードから始まる関数宣言と`var`で変数へ関数を代入する関数式では動作が異なります（「[関数と宣言（関数式）][]」を参照）

```js
// `hello`変数は巻き上げされるが、暗黙的に`undefined`となる
hello(); // => TypeError: hello is not a function

// `hello`変数へ関数を代入している
var hello = function(){
    return "Hello";
}
```

<!-- textlint-enable eslint -->

## ローカル変数の寿命とガーベッジコレクション

## クロージャー

- ファクトリとしての関数
- IIFE

[変数と宣言]: ../variables/README.md
[変数と宣言#let]: ../variables/README.md#let
[関数と宣言（関数式）]: ../function-declaration/README.md#function-expression
[文と式]: ../statement-expression/README.md
[undefinedはリテラルではない]: ../data-type/README.md##undefined-not-literal
[^TDZ]: この仕組みはTemporal Dead Zoneと呼ばれます。
