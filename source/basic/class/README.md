---
author: azu
---

# クラス

「クラス」と一言にいってもさまざまであるため、ここでは**構造**、**動作**（メソッド）、**状態**をもつもののことを示すことにします。
また、この章では概念を示す場合は**クラス**と呼び、クラスに関する構文（記述するコード）のことを`class`構文と呼びます。

**クラス**とは、**動作**を持った**構造**を定義でき、その構造からインスタンスを作成し、そのインスタンスは**状態**を持てるものです。
とても抽象的なことに見えますが、これは今までオブジェクトや関数を使って表現してきたものにも見えます。
実際にJavaScriptではES2015より前までは`class`構文はなく、関数を使いクラスのようなものを表現して扱っていました。

ES2015で`class`構文が導入されましたが、この`class`構文で定義したクラスは一種の関数オブジェクトです。
`class`構文ではプロトタイプベースの継承の仕組みの上に関数でクラスを表現しています。
そのため、`class`構文はクラスを作るための関数定義や継承をパターン化した書き方といえます。[^糖衣構文]

JavaScriptでは関数で学んだことの多くはクラスでもそのまま適応されます。
また、関数の定義方法として関数宣言文と関数式があるように、クラスにもクラス宣言文とクラス式があります。
この章では、`class`構文でのクラスの定義や継承、クラスの性質について学んでいきます。

## クラスの定義 {#class-declaration}

クラスを定義するには`class`構文を使いますが、クラスの定義方法にはクラス宣言文とクラス式があります。

まずは、クラス宣言文によるクラスの定義方法を見ていきます。

クラス宣言文では`class`キーワードを使い、`class クラス名{ }`のようにクラスを定義できます。
クラスは必ずコンストラクタを持ち、`constructor`という名前のメソッドとして定義します。
コンストラクタとは、そのクラスからインスタンスを作成する際にインスタンスに関する初期化を行うメソッドです。

```js
class MyClass {
    constructor() {
        // コンストラクタ関数の処理
    }
}
```

もうひとつの定義方法であるクラス式は、クラスを値として定義する方法です。
クラス式ではクラス名を省略できます。これは関数式における匿名関数と同じです。

```js
const MyClass = class MyClass {
    constructor() {}
};

const AnnonymousClass = class {
    constructor() {}
};
```

クラスは必ずコンストラクタを持ちますが、コンストラクタ関数内で何も処理がない場合はコンストラクタの記述を省略できます。

```js
class MyClassA {
    constructor() {
        // コンストラクタの処理が必要なら書く
    }
}
// コンストラクタの処理が不要な場合は省略できる
class MyClassB {

}
```

## クラスのインスタンス化 {#class-instance}

クラスは`new`演算子でインスタンスであるオブジェクトを作成できます。
`class`構文で定義したクラスからインスタンスを作成することを**インスタンス化**と呼びます。

```js
class MyClass {
}
// `MyClass`をインスタンス化する
const myClass = new MyClass();
// 毎回新しいインスタンス(オブジェクト)を作成する
const myClassAnother = new MyClass();
// それぞれのインスタンスの参照は異なる
console.log(myClass === myClassAnother); // => false
```

このままでは何もできない空のクラスなので、値を持ったクラスを定義してみます。
次のコードでは`x`座標と`y`座標の値をもつ`Point`というクラスを定義しています。

コンストラクタ関数の中でインスタンスの初期化処理を書きます。
コンストラクタ関数は`new`演算子でインスタンス化されるときに暗黙的によばれ、
コンストラクタのなかでの`this`はこれから新しく作るインスタンスオブジェクトとなります。
つまり、これから新しく作るインスタンスオブジェクトの`x`と`y`プロパティに値を代入して初期化しています。

```js
class Point {
    // コンストラクタ関数の仮引数として`x`と`y`を定義
    constructor(x, y) {
        // コンストラクタ関数における`this`はインスタンスを示すオブジェクト
        // インスタンスの`x`と`y`プロパティにそれぞれ値を設定する
        this.x = x;
        this.y = y;
    }
}
```

この`Point`クラスのインスタンスを`new`演算子を使って作成します。
`new`演算子には関数と同じように引数を渡すことができます。
`new`演算子の引数はクラスの`constructor`メソッド（コンストラクタ関数）の仮引数に渡されます。
そして、コンストラクタのなかではインスタンスオブジェクト(`this`）の初期化処理を行います。

```js
class Point {
    // 2. コンストラクタ関数の仮引数として`x`には`3`、`y`には`4`が渡る
    constructor(x, y) {
        // 3. インスタンス(`this`)の`x`と`y`プロパティにそれぞれ値を設定する
        this.x = x;
        this.y = y;
        // 4. return文がなくてもコンストラクタは自動的に`this`を返す
    }
}

// 1. コンストラクタ関数には引数として`3`と`4`渡してインスタンス化
const point = new Point(3, 4);
// 5. `Point`のインスタンスである`point`の`x`と`y`プロパティにはそれぞれ値が入る
console.log(point.x); // => 3
console.log(point.y); // => 4
```

コンストラクタ（`construtor`メソッド)の中では明示的に`return`文が出てきていないことに気づいたかもしれません。
通常の関数とは異なり、コンストラクタ関数は暗黙的に`this`（インスタンスオブジェクト）を返します。
次のように明示的に`return`文を書くこともできますが、通常はコンストラクタ関数内で`return`文は書きません。

```js
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        // コンストラクタ関数内では暗黙的に`this`が返される
        return this;
    }
}

const point = new Point(3, 4);
console.log(point.x); // => 3
console.log(point.y); // => 4
```

### [コラム] 関数でのクラス表現との違い

ES2015より前はこれらのクラスを`class`構文ではなく、関数で表現していました。
その表現方法は人によってさまざまで、これも`class`構文という統一した表現が導入された理由の1つです。

次のコードでは先ほどの`class`構文でのクラスを簡略化した関数での擬似コードです。
この関数でのクラス表現は、継承の仕組みなどは省かれていますが、`class`構文とよく似ています。

```js
// コンストラクタ関数
function Point(x, y) {
    // 新しいインスタンスオブジェクトを作成する
    const instance = Object.create(Function.prototype);
    // インスタンスの初期化処理
    instance.x = x;
    instance.y = y;
    return instance;
}
// `new`演算子でコンストラクタ関数から新しいインスタンスを作成
const point = new Point(3, 4);
```

クラスも一種の関数であるといったように、実際にクラスの`typeof`演算子の結果は`"function"`です。

```js
class MyClass {
}
// `typeof`演算子の結果は"function"
console.log(typeof MyClass); // => "function"
```

大きな違いとして、`class`構文で定義したクラスは関数と呼び出すことができません。
クラスは`new`演算子でインスタンス化して使うものなので、これはクラスの誤用を防げます。
一方、関数でのクラス表現はただの関数なので、当然関数として呼び出せます。

```js
// `class`構文でのクラス
class MyClass {
}
// 関数でのクラス表現
function MyClassLike() {
}
// 関数なので関数として呼び出せる
MyClassLike(); 
// クラスは関数として呼び出すと例外が発生する
MyClass(); // => TypeError: class constructors must be invoked with |new|
```

このように、`class`構文で定義したクラスは一種の関数ですが、その関数（クラス）はクラス以外には利用できないようになっています。

## [コラム] クラス名は大文字で始める

JavaScriptでは慣習としてクラス名は大文字で始まる名前を付けます。
これは、変数名にキャメルケースを使う慣習があるのと同じで、名前自体には特別なルールがあるわけではありません。
クラス名を大文字にしておき、そのインスタンスは小文字で開始すれば、名前が被らないため合理的な理由で好まれています。

```js
class Thing {}
const thing = new Thing();
```

[^糖衣構文]: `class`構文でのみしか実現できない機能はなく、読みやすさや分かりやさのために導入された構文という側面もあるためJavaScriptの`class`構文は糖衣構文と呼ばれることがあります。
