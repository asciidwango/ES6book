---
author: azu
---

# 非同期処理 {#async-handling}

この章ではJavaScriptにおける非同期処理について学んで行きます。
非同期処理はJavaScriptにおいてはとても重要な概念です。
また、JavaScriptを扱うブラウザやNode.jsなどにおいて非同期処理のみのAPIも多いため、非同期処理を避けることはできません。
そのため、非同期処理をあつかうためのパターンやPromiseというビルトインオブジェクト、さらにはAsync Functionとよばれる構文的なサポートがあります。

この章では非同期処理とはどのようなものかという話から、非同期処理での例外処理、非同期処理の扱い方を見ていきます。

## 同期処理 {#sync-processing}

多くのプログラミング言語ではコードの評価の仕方として**同期処理**（sync）と**非同期処理**（async）という大きな分類があります。

今まで書いていたコードは**同期処理**と呼ばれているもので、
コードを順番に文と式を評価したらその評価結果がその場で返されます。

同期処理ではコードを順番に処理していき、ひとつの処理が終わるまで次の処理は行いません。
同期処理では実行している処理はひとつだけとなるため、とても直感的な動作となります。

一方、同期的にブロックする処理が行われていた場合には問題があります。
同期処理ではひとつの処理が終わるまで次の処理を行うことができないためです。

次のコードの`blockTime`関数は指定した`timeout`ミリ秒だけ無限ループを行い同期的にブロックする処理です。
この`blockTime`関数を呼び出すと、指定時間経過するまで次の処理（次の行）が呼ばれません。

{{book.console}}
```js
// 指定した`timeout`ミリ秒経過するまで同期的にブロックする関数
function blockTime(timeout) { 
    const startTime = Date.now();
    // `timeout`ミリ秒経過するまで無限ループをする
    while (true) {
        const diffTime = Date.now() - startTime;
        if (diffTime >= timeout) {
            return; // 指定時間経過したら関数の実行を終了
        }
    }
}
console.log("処理を開始");
blockTime(3000); // 他の処理を3000ミリ秒（3秒間）ブロックする
console.log("この行が呼ばれるまで処理が3秒間ブロックされる");
```

このような同期的にブロックするのは、ブラウザでは大きな問題となります。
なぜなら、JavaScriptは基本的にブラウザのメインスレッド（UIスレッドとも呼ばれる）で実行されるためです。
そのため、JavaScriptで同期的にブロックする処理を行うと他の処理ができなくなるため、画面がフリーズしたような体感を与えてしまいます。

さきほどの例では3秒間も処理をブロックしているため、3秒間スクロールやクリックなどの他の操作が効かないといった悪影響がでます。

## 非同期処理 {#async-processing}

非同期処理は、コードを順番に文と式を評価したら処理は開始されますが、その評価結果を返しません。
（処理が開始されたことを表すオブジェクトなどを返すことはありますが、最終的な評価結果はすぐには手に入りません）

また非同期処理はコードを順番に処理していきますが、ひとつの非同期処理が終わるのを待たずに次の処理を評価します。
つまり、非同期処理では同時に実行している処理は複数あります。

JavaScriptにおいて代表的な非同期処理を行う関数として`setTimeout`関数があります。
`setTimeout`関数は`delay`ミリ秒後に、`コールバック関数`を呼び出すようにタイマーへ登録する非同期処理です。

<!-- doctest:disable -->

```js
setTimeout(コールバック関数, delay);
```

次のコードでは`setTimeout`関数を使い10ミリ秒後に同期的にブロックを行います。
`setTimeout`関数でタイマーに登録したコールバック関数は非同期的なタイミングで呼ばれます。
そのため`setTimeout`関数の次の行に書かれている同期的処理は、非同期処理よりも先に実行されます。

{{book.console}}
```js
// 指定した`timeout`ミリ秒経過するまで同期的にブロックする関数
function blockTime(timeout) { 
    const startTime = Date.now();
    while (true) {
        const diffTime = Date.now() - startTime;
        if (diffTime >= timeout) {
            return; // 指定時間経過したら関数の実行を終了
        }
    }
}

console.log("1. setTimeoutのコールバック関数を10ミリ秒後に実行します");
setTimeout(() => {
    console.log("3. ブロックする処理を開始します");
    blockTime(3000); // 他の処理を3秒間ブロックする
    console.log("4. ブロックする処理が完了しました");
}, 10);
// ブロックする処理は非同期なタイミングで呼び出されるので、次の行が先に実行される
console.log("2. 同期的な処理を実行します");
```

このコードを実行した結果のコンソールログは次のようになります。

1. setTimeoutのコールバック関数を10ミリ秒後に実行します
2. 同期的な処理を実行します
3. ブロックする処理を開始します
3. ブロックする処理が完了しました

このように、非同期処理（`setTimeout`のコールバック関数）は、コードの見た目上の並びとは異なる順番で実行されることがわかります。

## JavaScriptはメインスレッドで実行される {#JavaScript-and-main-thread}

ブラウザにおいて、JavaScriptはメインスレッドで実行されます。
メインスレッドはUIスレッドとも呼ばれ、重たいJavaScriptの処理はメインスレッドで実行する他の処理（画面の更新など）をブロックする問題について紹介しました。（ECMAScriptの仕様として規定されているわけではないため、すべてがメインスレッドで実行されているわけではありません）

非同期処理は名前から考えるとメインスレッド以外で実行されるように見えますが、
基本的には非同期処理も同期処理と同じようにメインスレッドで実行されます。
このセクションでは非同期処理がどのようにメインスレッドで実行されているかを簡潔に見ていきます。

次のコードは、`setTimeout`関数でタイマーに登録したコールバック関数が呼ばれるまで、実際にどの程度の時間がかかったかを計測しています。
また、`setTimeout`関数でタイマーに登録した次の行で同期的にブロックする処理を実行しています。

非同期処理（コールバック関数）がメインスレッド以外のスレッドで実行されるならば、
この非同期処理はメインスレッドでの同期的にブロックする処理の影響を受けないはずです。
しかし、実際にはこの非同期処理もメインスレッドで実行された同期的にブロックする処理の影響を受けます。

次のコードを実行すると`setTimeout`関数で登録したコールバック関数は、タイマーに登録した時間（10ミリ秒後）よりも大きく遅れてが呼び出されます。

{{book.console}}
```js
// 指定した`timeout`ミリ秒経過するまで同期的にブロックする関数
function blockTime(timeout) { 
    const startTime = Date.now();
    while (true) {
        const diffTime = Date.now() - startTime;
        if (diffTime >= timeout) {
            return; // 指定時間経過したら関数の実行を終了
        }
    }
}

const startTime = Date.now();
// 10ミリ秒後にコールバック関数を呼び出すようにタイマーに登録する
setTimeout(() => {
    const endTime = Date.now();
    console.log(`非同期処理のコールバックが呼ばれるまで${endTime - startTime}ミリ秒かかりました`);
}, 10);
console.log("ブロックする処理を開始します");
blockTime(3000); // 3秒間処理をブロックする
console.log("ブロックする処理が完了しました");
```

多くの環境では、このときの非同期処理のコールバックが呼ばれるまでは3000ミリ秒以上かかります。
このように**非同期処理**も**同期処理**の影響を受けることからも同じスレッドで実行されていることがわかります。

JavaScriptでは一部の例外を除き非同期処理が**並行処理（concurrent）**として扱われます。
並行処理とは、処理を一定の単位ごとに分けて処理を切り替えながら実行することです。

ECMAScriptの仕様では**JobQueue**と呼ばれるキューで後で行うタスクが管理されています。
次に処理するタスクをキューから1つ取り出し、タスクの処理が終わったら次のタスクを取り出りだすというのを繰り返してプログラムを評価しています。

同期処理では、キューにタスクを追加せずに現在ある処理を次々と処理しています。

- [ ] 同期処理のキューの図

一方の非同期処理では、キューのタスクを追加だけして、キューからタスクを取り出して実行するのは非同期で処理します。
`setTimeout`関数でタスク（コールバック関数）をキューへ追加し、指定時間後にタスクを取り出して処理します（コールバック関数を呼び出す）。
キューへ追加した非同期のタスクを取り出す前に同期的にブロックする処理がある場合は、ブロックする処理が終わってから非同期のタスク（コールバック関数）を取り出して実行します。

- [ ] 非同期処理のキューの図

これによって、非同期処理のタスクが同期的なブロックする処理によって実行が遅れるという現象を引き起こします。
そのためJavaScriptの非同期処理も基本的には1つのメインスレッドで処理されていると考えても間違いないでしょう。
これは、`setTimeout`関数のコールバック関数から外側のスコープのデータへのアクセス方法に制限がないことからもわかります。
もし、非同期処理が別スレッドで行われるならば自由なデータへのアクセスは競合状態（レースコンディション）を引き起こしてしまうためです。

ただし、非同期処理の中にもメインスレッドとは別のスレッドで実行できるAPIが実行環境によっては存在します。
たとえばブラウザでは[Web Worker][] APIを使いメインスレッド以外でJavaScriptを実行できるため、非同期処理を**並列処理（Parallel）**できます。並列処理とは、排他的に複数の処理を同時に実行することです。

Web WorkerでのJavaScriptはメインスレッドのJavaScriptとは異なるスレッドで実行されるため、お互いに同期的なブロックする処理の影響を受けにくくなります。
ただし、Web Workerとメインスレッドでのデータのやり取りには`postMessage`メソッドを利用する必要があります。そのため、`setTimeout`関数のコールバック関数とは異なりデータへのアクセス方法にも制限がつきます。

このように、非同期処理のすべてをひとくくりにはできませんが、基本的な非同期処理（タイマーなど）はメインスレッドで実行されているという性質を知ることは大切です。JavaScriptの大部分の**非同期処理**は**非同期的なタイミングで実行される処理**であると理解しておく必要があります。

## 非同期処理と例外処理 {#async-processing-and-error-handling}

非同期処理は処理の流れが同期処理とは異なることについて紹介しました。
これは非同期処理における**例外処理**においても大きな影響を与えます。

同期処理では、`try...catch`構文を使うことで同期的に発生した例外はキャッチできます。（詳細は「[例外処理][]」の章を参照）

{{book.console}}
```js
try {
    throw new Error("同期的なエラー");
} catch (error) {
    console.log("同期的なエラーをキャッチできる");
}
console.log("この文は実行されます");
```

非同期処理では、`try...catch`構文を使っても非同期的に発生した例外をキャッチできません。
次のコードでは、10ミリ秒後に非同期的なエラーを発生させています。
しかし、`try...catch`構文では次のような非同期エラーをキャッチすることはできません。

{{book.console}}
<!-- doctest: Error -->
```js
try {
    setTimeout(() => {
        throw new Error("非同期的なエラー");
    }, 10);
} catch (error) {
    console.log("非同期手なエラーはキャッチできない");
}
console.log("この文は実行されます");
```

`try`ブロックはそのブロック内で発生した例外をキャッチする構文です。
しかし、`setTimeout`関数で登録されたコールバック関数が実際に実行され例外を投げるのは、すべての同期処理が終わった後となります。
つまり、`try`ブロックで例外が発生しうるとマークした**範囲外**で例外が発生します。

そのため、`setTimeout`関数のコールバック関数における例外は、次のようにコールバック関数内で同期的なエラーとしてキャッチする必要があります。

{{book.console}}
```js
// 非同期処理の外
setTimeout(() => {
    // 非同期処理の中
    try {
        throw new Error("エラー");
    } catch (error) {
        console.log("エラーをキャッチできる");
    }
}, 10);
console.log("この文は実行されます");
```

このようにコールバック関数内でエラーをキャッチはできますが、**非同期処理の外**からは**非同期処理の中**で例外が発生したかは分かりません。
そのため、**非同期処理の中**で例外を発生した場合に、その例外を**非同期処理の外**へ伝える方法が必要です。

この非同期処理で発生した例外の扱い方についてはさまざまなパターンがあります。
この章では主要な非同期処理と例外の扱い方としてエラーファーストコールバック、Promise、Async Functionの3つを見ていきます。
現実のコードではすべてのパターンが実用的です。そのため、非同期処理の選択肢を増やす意味でも理解することは重要です。

## エラーファーストコールバック {#error-first-callback}

ECMAScript 2015（ES2015）でPromiseが仕様へ入るまで、非同期処理中に発生した例外を扱う統一的な方法は存在しませんでした。
ES2015より前までは、**エラーファーストコールバック**という非同期処理中に発生した例外を扱う方法を決めたコミュニティベースのルールが広く使われていました。

エラーファーストコールバックとは、次のような非同期処理におけるコールバック関数の呼び出し方を決めたルールです。

- 処理に失敗した場合は、コールバック関数の1番目の引数にエラーオブジェクトを渡して呼び出す
- 処理に成功した場合は、コールバック関数の1番目の引数には`null`を渡し、2番目以降の引数に成功時の結果などを渡して呼び出す

つまり、ひとつのコールバック関数で失敗した場合と成功した場合の両方を扱うルールとなります。

たとえば、Node.jsでは`fs.readFile`関数というファイルシステムからファイルをロードする非同期処理を行う関数があります。
指定したパスのデータを読むため、ファイルが存在しない場合やアクセス権限の問題から読み取りに失敗することがあります。
そのため、`fs.readFile`関数の第2引数にわたすコールバック関数にはエラーファーストコールバックスタイルの関数を渡します。

ファイルを読み込むことに失敗した場合は、コールバック関数の1番目の引数には`Error`オブジェクトが渡されます。
ファイルを読み込むことに成功した場合は、コールバック関数の1番目の引数には`null`、2番目の引数に読み込んだデータを渡します。

<!-- doctest:disable -->
```js
fs.readFile("./example.txt", (error, data) => {
    if (error) {
        // 読み込み中にエラーが発生しました
    } else {
        // データを読み込むことができた
    }
});
```

このエラーファーストコールバックはNode.jsでは広く使われ、Node.jsの標準APIにおいても非同期処理を行う関数では利用されています。
詳しい扱い方については[ユースケース: Node.jsでCLIアプリケーション][]にて紹介します。

実際にエラーファーストコールバックで非同期な例外処理を扱うコードを書いてみましょう。

次のコードの`dummyFetch`関数は、擬似的なリソースの取得を行う非同期な処理です。
第1引数に任意のパスを受け取り、第2引数にエラーファーストコールバックスタイルの関数を受け取ります。
第1引数の任意のパスにマッチするリソースがある場合には、第2引数のコールバック関数には`null`とレスポンスオブジェクトを渡して呼び出します。
一方、任意のパスにマッチするリソースがない場合には、第2引数のコールバック関数にはエラーオブジェクトを渡して呼び出します。

{{book.console}}
```js
/**
 * 1000ミリ秒未満のランダムなライミングでレスポンスを擬似的なデータ取得関数
 * 指定した`path`にデータがある場合は`callback(null, レスポンス)`を呼ぶ
 * 指定した`path`にデータがない場合は`callback(エラー)`を呼ぶ
 */
function dummyFetch(path, callback) {
    setTimeout(() => {
        // /success から始まるパスにはリソースがあるという設定
        if (path.startWith("/success")) {
            callback(null, { body: `Response body of ${path}` });
        } else {
            callback(new Error("NOT FOUND"));
        }
    }, 1000 * Math.random());
}
// /success/data にリソースが存在するので、`response`にはデータが入る
dummyFetch("/success/data", (error, response) => {
    if (error) {
        console.log(error); // この文は実行されません
    } else {
        console.log(result); // => { body: "Response body of /success/data" }
    }
});
// /failure/data にリソースは存在しないので、`error`にはエラーオブジェクトが入る
dummyFetch("/failure/data", (error, response) => {
    if (error) {
        console.log(error); // => Error: NOT FOUND
    } else {
        console.log(response); // この文は実行されません
    }
});
```

このようにコールバック関数の1番目の引数にはエラーオブジェクトまたは`null`を入れ、それ以降の引数にデータを渡すというルール化したものを**エラーファーストコールバック**と呼びます。

非同期処理中に例外が発生して生じたエラーをコールバック関数で受け取る方法は他にもやり方があります。
たとえば、成功したときに呼び出すコールバック関数と失敗したときに呼び出すコールバック関数の2つを受け取る方法があります。
さきほどの`dummyFetch`関数を2種類のコールバック関数を受け取る形に変更すると次のような実装になります。

```js
/**
 * リソースの取得に成功した場合は`successCallback(レスポンス)`を呼び出す
 * リソースの取得に失敗した場合は`failureCallback(エラー)`を呼び出す
 */
function dummyFetch(path, successCallback, failureCallback) {
    setTimeout(() => {
        if (path.startWith("/success")) {
            successCallback({ body: `Response body of ${path}` });
        } else {
            failureCallback(new Error("NOT FOUND"));
        }
    }, 1000 * Math.random());
}
```

このように**非同期処理の中**で例外が発生した場合に、その例外を**非同期処理の外**へ伝える方法はさまざまな手段が考えられます。
エラーファーストコールバックはその形を決めた**ただの共通のルール**の1つです。そのため、非同期処理ではエラーファーストコールバック以外の方法が使われていることもあります。
一方で、非同期処理における例外処理のルールを決めることのメリットとして、エラーハンドリングのパターン化ができることなどがあります。

エラーファーストコールバックは非同期処理におけるエラーハンドリングの**ただの共通のルール**でした。
そのためエラーファーストコールバックというルールを破っても、構文として問題があるわけではありません。

しかしながら、最初に書いたようにJavaScriptでは非同期処理は頻出する問題です。
ただのルールではなく、ECMAScriptの仕様として非同期処理を扱う方法が求められていました。
そこで、ES2015では`Promise`という非同期処理を扱えるようにするビルトインオブジェクトが導入されました。

次のセクションでは、ES2015で導入された`Promise`について見ていきます。

## [ES2015] Promise {#promise}

[Promise][]はES2015で導入された非同期処理の結果を表現するビルドインオブジェクトです。

エラーファーストコールバックは非同期処理を扱うコールバック関数の最初の引数にエラーオブジェクトを渡すというルールでした。`Promise`はこれを発展させたもので、単なるルールではなくオブジェクトという形にして非同期処理を統一的なインタフェースで扱うことを目的にしています。

`Promise`はビルトインオブジェクトであるためさまざまなメソッドを持ちますが、
まずはエラーファーストコールバックと`Promise`での非同期処理のコード例を見てみます。

次のコードの`asyncTask`関数はエラーファーストコールバックを受け取る非同期処理の例です。

エラーファーストコールバックでは、非同期処理に成功した場合は1番目の引数へ`null`を渡し、2番目以降の引数に結果を渡します。
一方、非同期処理に失敗した場合は1番目の引数にはエラーオブジェクトを渡すというルールでした。

```js
asyncTask((error, result) => {
    if (error) {
        // 非同期処理が失敗したときの処理
    } else {
        // 非同期処理が成功したときの処理
    }
});
```

次のコードの`asyncTask`関数は`Promise`インスタンスを返す非同期処理の例です。
Promiseでは、非同期処理に成功したときの処理を`then`メソッドへコールバック関数を渡し、
失敗したときの処理を`catch`メソッドへコールバック関数を渡します。

エラーファーストコールバックとはことなり、非同期処理（`asyncTask`関数）は`Promise`インスタンスを返しています。
その返された`Promise`インスタンスに対して成功と失敗それぞれのコールバック関数を渡すという形になります。

```js
asyncTask().then(()=> {
    // 非同期処理が成功したときの処理
}).catch(() => {
    // 非同期処理が失敗したときの処理
});
```


`Promise`インスタンスのメソッドによって引数に渡せるものが決められているため、非同期処理の流れも一定のやり方に統一されます。また非同期処理（`asyncTask`関数）はコールバック関数を受け取るのではなく、`Promise`インスタンスを返すという形に変わっています。この`Promise`という統一されたインターフェースがあることで、 さまざまな非同期処理のパターンを形成できます。

つまり、複雑な非同期処理等を上手くパターン化できるというのが`Promise`の役割であり、 Promiseを使う理由のひとつであるといえるでしょう。
このセクションでは、非同期処理を扱うビルトインオブジェクトである`Promise`について見ていきます。

### `Promise`インスタンスの作成 {#promise-instance}

`Promise`はコンストラクタから`new`演算子で`Promise`のインスタンスを作成して利用します。
このときのコンストラクタには`resolve`と`reject`の2つの引数を取る`executor`関数を渡します。
`executor`関数で非同期処理を開始し、非同期処理が成功した場合は`resolve`関数を呼び、失敗した場合は`reject`関数を呼だします。

```js
const executor = (resolve, reject) => {
    // 非同期の処理が成功したときはresolveを呼ぶ
    // または、非同期の処理が失敗したときにはrejectを呼ぶ
};
const promise = new Promise(executor);
```

このPromiseインスタンスの`Promise#then`メソッドで、Promiseが`resolve`（成功）、`reject`（失敗）したときに呼ばれるコールバック関数を登録します。
`then`メソッドでは2つの引数を渡すことができ、第一引数には`resolve`（成功）に呼ばれるコールバック関数、第二引数には`reject`（失敗）に呼ばれるコールバック関数を渡します。

```js
// Promiseインスタンスを作成
const promise = new Promise((resolve, reject) => {
    // 非同期の処理が成功したときはresolveを呼ぶ
    // または、非同期の処理が失敗したときにはrejectを呼ぶ
});
const onFulfilled = () => {
    console.log("resolveされたときに呼ばれる");
};
const onRejected = () => {
    console.log("rejectされたときに呼ばれる");
};
// `then`メソッドで成功時と失敗時に呼ばれるコールバック関数を登録
promise.then(onFulfilled, onRejected);
```

`Promise`コンストラクタの`resolve`と`reject`、`then`メソッドの`onFulfilled`と`onRejected`は次のような関係となります。

- `resolve`（成功）した時
    - `onFulfilled`が呼ばれる
- `reject`（失敗）した時
    - `onRejected` が呼ばれる

### Promiseの状態 {#promise-status}

`Promise`インスタンスには、内部的に次の3つの状態が存在します。

- Fulfilled
    - `resolve`（成功）したときの状態。このとき`onFulfilled`が呼ばれる
- Rejected
    - `reject`（失敗）したときの状態。このとき`onRejected`が呼ばれる
- Pending
    - FulfilledまたはRejectedではない状態。Promiseインスタンスの初期状態

これらの状態はECMAScriptの仕様として内部的に定められている状態です。
しかし、この状態をPromiseのインスタンスから取り出す方法はありません。
そのため、APIとしてこの状態を直接扱うことはできませんが、Promiseについて理解するのに役に立ちます。

### `Promise#then`と`Promise#catch` {#promise-then-and-catch}

`Promise`のようにコンストラクタに関数を渡すパターンは今までなかったので、具体的な例を見ていきます。

次のコードの`dymmyFetch`関数は`Promise`のインスタンスを作成して返します。
`dummyFetch`関数はリソースの取得に成功した`resolve`関数を呼び、失敗した場合は`reject`関数を呼びます。
`resolve`に渡した値は、`then`メソッドの1番目のコールバック関数（`onFulfilled`）に渡されます。
`reject`に渡したエラーオブジェクトは、`then`メソッドの2番目のコールバック関数（`onRejected`）に渡されます。

```js
/**
 * 1000ミリ秒未満のランダムなライミングでレスポンスを擬似的なデータ取得関数
 * 指定した`path`にデータがある場合は成功として`resolve`を呼ぶ
 * 指定した`path`にデータがない場合は失敗として`reject`を呼ぶ
 */
function dummyFetch(path) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            if (path.startWith("/success")) {
                resolve({ body: `Response body of ${path}` });
            } else {
                reject(new Error("NOT FOUND"));
            }
        }, 1000 * Math.random());
    });
}
// `then`メソッドで成功時と失敗時に呼ばれるコールバック関数を登録
// /success/data のリソースは存在するので成功しonFulfilledが呼ばれる
dummyFetch("/success/data").then(function onFulfilled(response) {
    console.log(response); // => { body: "Response body of /success/data" }
}, function onRejected(error) {
    console.log(error); // この文は実行されません
});
// /failure/data のリソースは存在しないのでonRejectedが呼ばれる
dummyFetch("/failure/data").then(function onFulfilled(response) {
    console.log(response); // この文は実行されません
}, function onRejected(error) {
    console.log(error); // Error: "NOT FOUND"
});
```

`Promise#then`メソッドは成功と失敗のコールバック関数の2つを受け取りますが、どちらの引数も省略できます。

次のコードの`delay`関数は一定時間後に解決（`resolve`）されるPromiseインスタンスを返します。
このPromiseインスタンスに対して`then`メソッドで成功時のコールバック関数だけを登録しています。

```js
function delay(timeoutMs) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve();
        }, timeoutMs);
    });
}
// `then`メソッドで成功時のコールバック関数だけを登録
delay(1000).then(() => {
    console.log("1000ミリ秒後に呼ばれる");
});
```

一方、`then`メソッドでは失敗時のコールバック関数だけの登録もできます。
このとき`then(undefined, onRejected)`のように第1引数には`undefined`を渡す必要があります。
同様のことを行う方法として`Promise`には失敗時のコールバック関数だけを登録する`Promise#catch`メソッドが用意されています。

次のコードでは`then`メソッドと`catch`メソッドで失敗時のエラー処理をしていますが、どちらも同じ意味となります。
`then`メソッドに`undefined`を渡すのはわかりにくいため、失敗時の処理だけを行う場合は`catch`メソッドの利用を推奨します。

```js
function errorPromise(message) {
    return new Promise((resolve, reject) => {
        reject(new Error(message));
    });
}
// `then`メソッドで失敗時のコールバック関数だけを登録
errorPromise("thenでエラーハンドリング").then(undefined, (error) => {
    console.log(error); // => Error: thenでエラーハンドリング
});
// `catch`メソッドで失敗時のコールバック関数を登録
errorPromise("catchでエラーハンドリング").then(undefined, (error) => {
    console.log(error); // => Error: catchでエラーハンドリング
});
```

[文と式]: ../statement-expression/README.md
[例外処理]: ../error-try-catch/README.md
[Web Worker]: https://developer.mozilla.org/ja/docs/Web/API/Web_Workers_API/Using_web_workers
[Promise]: https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise
[ユースケース: Node.jsでCLIアプリケーション]: ../../use-case/nodecli/README.md
