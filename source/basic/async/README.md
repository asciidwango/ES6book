---
author: azu
---

# 非同期処理 {#async-handling}

この章ではJavaScriptにおける非同期処理について学んで行きます。
非同期処理はJavaScriptにおいてはとても重要な概念です。
また、JavaScriptを扱うブラウザやNode.jsなどにおいて多くの非同期処理を行うAPIが提供されているため、非同期処理を避けることはできません。
そのため、非同期処理をあつかうためのパターンやPromiseというビルトインオブジェクト、さらにはAsync Functionとよばれる構文的なサポートがあります。

この章では非同期処理とはどのようなものかという話から、非同期処理での例外処理、非同期処理の扱い方を見ていきます。

## 同期処理 {#sync-processing}

多くのプログラミング言語ではコードの評価の仕方として**同期処理**（sync）と**非同期処理**（async）という大きな分類があります。

今まで書いていたコードは**同期処理**と呼ばれているもので、
コードを順番に文と式を評価したらその評価結果がその場で返されます。

同期処理ではコードを順番に処理していき、ひとつの処理が終わるまで次の処理は行いません。
同期処理では実行している処理はひとつだけとなるため、とても直感的な動作となります。

一方、同期処理でとても重たい処理が行われていた場合には問題があります。
同期処理ではひとつの処理（重たい処理）が終わるまで次の処理を行うことができないためです。

次のコードでは`createLargeArray`関数で巨大な配列を作り初期化したものを返しています。
しかし、`createLargeArray`関数は1000万回の`0`を代入するというとても重たい処理です。
そのため、`createLargeArray`関数を呼び出したあとの次の処理が呼ばれるまでには時間がかかります。

{{book.console}}
```js
// 重たい処理の例として10の6乗コの要素を持つ配列を0に初期化し返す
function createLargeArray() {
    console.log("重たい処理を実行します");
    return new Array(10e6).fill(0);
}

const array = createLargeArray();
// "重たい処理"が終わるまで次の処理は実行されない
console.log(array.length); // => 10e6
```

同期処理は直感的な処理順ですが、このような重たい処理や終わるかわからない処理がある場合に問題となります。
特にブラウザにおいては、このような重たい同期処理はブラウザの体感への悪影響を与えるため問題となりやすいです。
なぜなら、JavaScriptは基本的にブラウザのメインスレッド（UIスレッドとも呼ばれる）で実行されるためです。
そのため、JavaScriptで重たい同期処理を行うと表示しているページの描画を更新されなくなり、画面がフリーズしたような体感を与えてしまいます。

## 非同期処理 {#async-processing}

非同期処理は、コードを順番に文と式を評価したら処理は開始されますが、その評価結果を返しません。
（処理が開始されたことを表すオブジェクトなどを返すことはありますが、最終的な評価結果はすぐには手に入りません）

また非同期処理はコードを順番に処理していきますが、ひとつの非同期処理が終わるのを待たずに次の処理を評価します。
つまり、非同期処理では同時に実行している処理は複数あります。

JavaScriptにおいて代表的な非同期処理を行う関数として`setTimeout`関数があります。
`setTimeout`関数は`delay`ミリ秒後に、`コールバック関数`を呼び出すようにタイマーへ登録する非同期処理です。

<!-- doctest:disable -->

```js
setTimeout(コールバック関数, delay);
```

次のコードでは`setTimeout`関数を使い10ミリ秒後に非同期で重たい処理を行います。
`setTimeout`関数のコールバックは非同期で呼ばれます。
そのため、次の行に書かれている同期的処理は非同期処理よりも先に評価されます。

{{book.console}}
```js
console.log("1. 重たい処理を10ミリ秒後に実行します");
setTimeout(() => {
    // 重たい処理の例として10の6乗コの要素を持つ配列を0に初期化する
    new Array(10e6).fill(0);
    console.log("3. 重たい非同期的な処理が完了しました");
}, 10);
// "重たい処理"は非同期で実行されるため次の処理が先の実行される
console.log("2. 次の同期的な処理を実行します");
```

このコードを実行した結果のコンソールログは次のようになります。

1. 重たい処理を10ミリ秒後に実行します
2. 次の同期的な処理を実行します
3. 重たい非同期的な処理が完了しました

このように、非同期処理（`setTimeout`のコールバック関数）は、コードの見た目上の並びとは異なる順番で実行されることがわかります。

## [コラム] JavaScriptはメインスレッドで実行される {#JavaScript-and-main-thread}

ブラウザにおいて、JavaScriptはメインスレッドで実行されます。
メインスレッドはUIスレッドとも呼ばれ、重たいJavaScriptの処理はメインスレッドで実行する他の処理（画面の更新など）をブロックする問題について紹介しました。
（ECMAScriptの仕様として規定されているわけではないため、すべてがメインスレッドで実行されているわけではありません）

基本的には非同期処理も同期処理と同じようにメインスレッドで実行されます。
非同期処理は名前から考えるとメインスレッド以外で実行されるように見えますが、
非同期処理がどのようにメインスレッドで実行されているかを簡潔に見ていきます。

次のコードは、`setTimeout`関数でタイマーに登録したコールバック関数が呼ばれるまで、実際にどの程度の時間がかかったかを計測しています。
また、`setTimeout`関数でタイマーに登録した次の行で重たい処理を実行しています。

`setTimeout`関数による非同期処理がメインスレッドとは異なるスレッドで実行されてるならば、
コールバック関数はメインスレッドの重たい処理の影響は受けないはずです。
しかし、実際にはメインスレッドの重たいの影響を受けるため、タイマーに登録した時間より遅れて非同期でコールバック関数が呼び出されます。

{{book.console}}
```js
const startTime = Date.now();
// 10ミリ秒後にコールバック関数を呼び出すようにタイマーに登録する
setTimeout(() => {
    const endTime = Date.now();
    console.log(`非同期処理のコールバックが呼ばれるまで${endTime - startTime}ミリ秒かかりました`);
}, 10);
console.log("重たい同期処理を実行します");
new Array(10e6).fill(0);
console.log("重たい同期処理を実行しました");
```

どの程度遅れるかは実行している端末にもよりますが、MacBook Pro 2017モデルでは、非同期処理のコールバックが呼ばれるまで1500ミリ秒かかりました。
このように**非同期処理**も**同期処理**の影響を受けることからも同じスレッドで実行されていることがわかります。

JavaScriptでは多くの非同期処理が**平行（concurrent）**して処理されます。
ECMAScriptの仕様ではJobQueueと呼ばれるキューで次の行うタスクが管理されています。
次に処理するタスクをキューから1つ取り出し、タスクの処理が終わったら次のタスクを取り出りだすというのを繰り返してプログラムを評価しています。

同期処理では、キューにタスクを追加して、すぐにキューからタスクを取り出して処理するということを繰り返しています。

- [ ] 同期処理のキューの図

一方の非同期処理では、キューのタスクを追加だけして、キューからタスクを取り出して実行するのは非同期で処理します。
`setTimeout`関数でタスク（コールバック関数）をキューへ追加し、指定時間後にタスクを取り出して処理します（コールバック関数を呼び出す）。
その非同期のタスクを取り出す前に別の同期的な重たい処理がある場合は、重たい処理が終わるまで非同期のタスクを取り出して実行（コールバック関数を実行）できなくなるというわけです。

- [ ] 非同期処理のキューの図

同期処理と非同期処理がどちらも同じキュー上で管理されるため、実行順は異なりますがどちらも処理が終わるまで待つという影響を受けます。
そのため「JavaScriptはシングルスレッドで処理されている」と言われることがあります。

非同期処理の中にも例外的にメインスレッドとは別のスレッドで実行できるAPIが実行環境で提供されている場合があります。
ブラウザでは[Web Worker][] APIはメインスレッドではないところでJavaScriptを実行できため、非同期処理を**並列（Parallel）**に処理できます。
このように、非同期処理ですべてをひとくくりにはできませんが、基本的な非同期処理（タイマーなど）はメインスレッドで実行されているという性質を知ることは大切です。

## 非同期処理と例外処理 {#async-processing-and-error-handling}

非同期処理は処理の流れが同期処理とは異なることについて紹介しましたが、
これは例外処理においても大きな影響を与えます。

同期処理では、`try...catch`構文を使うことで同期的に発生した例外はキャッチできます。（詳細は「[例外処理][]」の章を参照）

{{book.console}}
```js
try {
    throw new Error("同期的なエラー");
} catch (error) {
    console.log("同期的なエラーをキャッチできる");
}
console.log("この文は実行されます");
```

非同期処理では、`try...catch`構文を使っても非同期的に発生した例外をキャッチできません。
次のコードでは、10ミリ秒後に非同期的なエラーを発生させています。
しかし、`try...catch`構文では次のような非同期エラーをキャッチすることはできません。

{{book.console}}
<!-- doctest: Error -->
```js
try {
    setTimeout(() => {
        throw new Error("非同期的なエラー");
    }, 10);
} catch (error) {
    console.log("非同期手なエラーはキャッチできない");
}
console.log("この文は実行されます");
```

コード的には`try`ブロックの中で、`setTimeout`関数によってタイマーへコールバック関数が登録されます。
`try`ブロックはそのブロック内で起きた同期的なエラーのみをキャッチする構文です。
しかし、登録されたコールバック関数が実際に実行され例外を投げるのは、すべての同期処理が終わった後となります。
つまり、`try`ブロックで例外が発生しうるとマークした**範囲外**で例外が発生します。

そのため、`setTimeout`関数のコールバック関数における例外は、次のようにコールバック関数内で同期的なエラーとしてキャッチする必要があります。

{{book.console}}
```js
try {
    setTimeout(() => {
        try {
            // setTimeoutの外側からは非同期なエラーという扱い
            // setTimeoutの内側からは同期的なエラーという扱い
            throw new Error("エラー");
        } catch (error) {
            console.log("同期的なエラーをキャッチできる");
        }
    }, 10);
} catch (error) {
    console.log("非同期的なエラーはキャッチできない");
}

console.log("この文は実行されます");
```

このような非同期処理では、setTimeoutの内側の例外をキャッチできますが、setTimeoutの外側からは例外は発生したかわかりません。

JavaScriptでは、この非同期処理と例外処理を扱う方法としてさまざまなパターンが存在しています。
次の章では、そのパターンとしてエラーファーストコールバック、Promise、Async Functionについてを見ていきます。

[文と式]: ../statement-expression/README.md
[例外処理]: ../error-try-catch/README.md
[Web Worker]: https://developer.mozilla.org/ja/docs/Web/API/Web_Workers_API/Using_web_workers
