---
author: azu
---


# ラッパーオブジェクト

JavaScriptのデータ型は大きくプリミティブ型とオブジェクトに分けられることを説明しました。（「[データ型とリテラル][]」を参照）
しかし、JavaScriptではプリミティブ型の値においてもメソッドを呼び出すことができます。

```js
// String#toLocaleUpperCaseを呼び出している
"string".toLocaleUpperCase(); // => "STRING"
```

しかし、プリミティブ型の値である文字列は`String`オブジェクトのインスタンスではありません。
それなのに文字列が`String`のインスタンスメソッドを呼び出せることは一見不思議です。

この章では、プリミティブ型の値がなぜオブジェクトのメソッドを呼び出せるのかについて解説します。

## プリミティブ型とラッパーオブジェクト

<!--　textlint-disable preset-ja-technical-writing/max-ten -->

プリミティブ型のデータのうち、真偽値（Boolean）、数値（Number） 、文字列（String）、シンボル（Symbol）にはそれぞれ対応するオブジェクトが存在します。たとえば、文字列に対応するオブジェクトとして、`String`オブジェクトがあります。

この`String`オブジェクトを`new`することで`String`オブジェクトのインスタンスを作ることができます。

<!-- textlint-enable -->

```js
// "string"の値をラップしたStringのインスタンスを生成
var string = new String("string");
// StringのインスタンスメソッドであるtoLocaleUpperCaseを呼び出す
string.toLocaleUpperCase(); // => "STRING"
```

このようにインスタンス化されたものは、プリミティブ型の値を包んだ（ラップした）オブジェクトといえます。
そのため、このようなオブジェクトをプリミティブ型の値に対しての**ラッパーオブジェクト**と呼ばれます。

ラッパーオブジェクトとプリミティブ型の対応は次のとおりです。


| ラッパーオブジェクト | プリミティブ型 |
| ---------- | ---------------------- |
| `Boolean`  | 真偽値 - `true`/`false`        |
| `Number`   | 数値 - `1`/`2`など            |
| `String`   | 文字列 - `"文字列"`など          |
| `Symbol`   | シンボル - `Symbol("説明")`など   |

注記: `undefined`と`null`に対応するラッパーオブジェクトはありません

ひとつ注意点として、ラッパーオブジェクトは名前のとおりオブジェクトです。
そのため、次のように`typeof`演算子でラッパーオブジェクトを見ると`"object"`です。

```js
var string = "文字列";
console.log(typeof string); // => "string";
var stringWrapper = new String("文字列");
console.log(typeof stringWrapper); // => "object";
```

## プリミティブとラッパーオブジェクトの相互変換

ラッパーオブジェクトがプリミティブ型の値である文字列が`String`のインスタンスメソッドを呼び出せる仕組みに関係しています。
JavaScriptでは、プリミティブ型の値に対してプロパティアクセスする時、自動で対応するラッパーオブジェクトに変換されます。
つまり、`"string"`という文字列は、自動的に`new String("string")`のようなラッパーオブジェクトへ変換されています。
これにより、プリミティブ型の値である文字列が`String`のインスタンスメソッドを呼び出すことができます。

```js
var str = "string";
// プリミティブ型の値に対してメソッド呼び出しを行うとき、次のような変換が行われる
str.toLocaleUpperCase();
// `str`へアクセスする際に、"string"がラッパーオブジェクトへ変換される
// ラッパーオブジェクトはStringのインスタンスなのでメソッドを呼び出せる
new String(str).toLocaleUpperCase();
```

一方、ラッパーオブジェクトからプリミティブ型の値を取りだすこともできます。

`ラッパーオブジェクト.valueOf`メソッドを呼び出すことで、ラッパーオブジェクトから値を取り出せます。
たとえば、次のように文字列のラッパーオブジェクトから`valueOf`メソッドで文字列を取りだせます。

```js
var stringWrapper = new String("文字列");
// プリミティブ型の値を取得する
console.log(stringWrapper.valueOf()); // => "文字列"
```

しかし、実際には`valueOf`メソッドを明示的に呼び出す必要はありません。
実は、ラッパーオブジェクトからプリミティブ型の値への変換も評価時に自動的に行われます。
そのため、先ほどの例は`valueOf`メソッドを呼び出さなくても評価結果が自動的に文字列（オブジェクトではなく）となります。

```js
var stringWrapper = new String("文字列");
// valueOfメソッドを呼び出してないが、評価結果はプリミティブ型の値
console.log(stringWrapper); // => "文字列"
```

このように、プリミティブ型の値とラッパーオブジェクトの相互変換は殆どのケースで自動的に行われます。[^1]

文字列などのプリミティブ型のデータを作成する方法として、リテラルを使う方法とラッパーオブジェクトを使う方法があります。
しかし、常にリテラルを使うことを推奨します。なぜなら、`new String("string")`のようにラッパーオブジェクトのインスタンスを生成する利点はありません。
ラッパーオブジェクトを`typeof`演算子で評価した結果が、プリミティブ型ではなく`"object"`となり、混乱を招くのも避けるべき理由です。

そのため、常にリテラルを使うことでラッパーオブジェクトは意識する必要がなくなります。

```js
// OK: リテラルを使う
var string = "文字列";
// NG: ラッパーオブジェクトを使う
var stringWrraper = new String("文字列");
```

## まとめ

この章では、プリミティブ型の値がなぜメソッド呼び出しできるのかについて解説しました。
その仕組みの背景にはプリミティブ型に対応したラッパーオブジェクトの存在があります。
プリミティブ型の値のプロパティへアクセスする際に、自動的にラッパーオブジェクトへ変換されることでメソッド呼び出しなどが可能となっています。

「JavaScriptはすべてがオブジェクトである」と言われることがあります。
プリミティブ型はオブジェクトではありませんが、プリミティブ型に対応したラッパーオブジェクトが用意されています。（`null`と`undefined`を除く）
そのため、「すべてがオブジェクトのように見える」というのが正しい認識となるでしょう。


[データ型とリテラル]: ../data-type/README.md  "データ型とリテラル"
[^1]: このような値型から参照型の変換は一般にボックス化(ボクシング)、逆の変換はボックス化解除(アンボクシング)と呼ばれます
