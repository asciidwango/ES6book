---
author: azu
---

# ECMAScript策定プロセス

ここまでJavaScriptの基本文法について見ていきましたが、その文法を定めるECMAScriptという仕様自体がどのように変化していくのかを見ていきましょう。
ECMAScriptは[Ecma International][]という団体によって標準化されている仕様です。
そのEcma International中のTC39（Technical Committeeの39番目）という技術委員会によって、どのような機能を仕様へ入れるかを議論しています。
この技術委員会はMicroSoft、Mozilla、Google、AppleといったブラウザベンダーやECMAScriptに関心のある企業などによって構成されます。

ここで、簡単にECMAScriptのバージョンの歴史を振り返ってみましょう。

| バージョン | 日付       |
| -------- | --------  |
| 1        | 1997年6月  |
| 2        | 1998年6月  |
| 3        | 1999年12月 |
| 4        | 策定されずに破棄[^ES4] |
| 5        | 2009年12月 |
| 5.1      | 2011年6月  |
| 2015     | 2015年6月  |
| 2016     | 2016年6月  |
| 2017     | 2017年6月  |

<!-- textlint-disable -->

ES5.1からES2015がでるまで6年もの歳月がかかっているの対して、ES2015以降は毎年リリースされています。
また、ES2015以降は西暦がバージョンとなっています。
これはES2015で仕様策定プロセスの変更が行われ、後述するようにバージョンそのものは重要ではなくなったためです。

<!-- textlint-enable -->

## 仕様策定のプロセス

ES2015以前はすべての仕様の合意が取れるまで延々と議論を続けすべてが決まってからリリースされていました。
ES2016以降は、ECMAScriptは毎年リリースするためにこの策定プロセスが変更されました。

ES2016以降は次のような仕様策定のプロセスを取っています。[^process]

仕様に追加する機能（API、構文、修正など）をそれぞれ個別の**プロポーザル**（提案書）として進めていきます。
現在策定中のプロポーザルは[GitHub][tc39/proposals]にて公開されています。
それぞれのプロポーザルは責任者である**チャンピオン**と**ステージ**（Stage）と呼ばれる`0`から`4`の5段階の状態を持ちます。

| ステージ  | ステージの概要                                               |
| :------: | ------------------------------------------------------------ |
|    0     | アイデアの段階                                               |
|    1     | 機能提案の段階                                               |
|    2     | 機能の仕様書ドラフトを作成した段階                               |
|    3     | 仕様としては完成しており、ブラウザの実装やフィードバックを求める段階  |
|    4     | 仕様策定が完了し、2つ以上の実装が存在している。<br />正式にECMAScriptにマージできる段階 |

プロポーザルのステージは2ヶ月に1度行われるTC39のミーティングにおいて、プロポーザルごとにステージを進めるかどうかを議論します。[^meeting]
そして毎年のECMAScriptをリリースするタイミングで、Stage 4となっているプロポーザルをマージしてECMAScript 20XXとしてリリースします。

つまり、すべての仕様の合意が取れてからリリースするのではなく、合意が取れた仕様からリリースするという仕組みにかわっています。
このような仕様策定プロセスに変化を加えたのは、ECMAScript（2015以前）のリリースに長い歳月がかかってしまい言語の進化が停滞してしまったのが大きな要因です。

この仕様策定プロセスの変更は、ECMAScriptに含まれる機能の形にも影響しています。

たとえば、`class`構文の策定は**最小で最大のクラス**（maximally minimal classes）と呼ばれる形で提案されています。
これによりES2015で`class`構文が導入されましたが、クラスとして合意が取れる最低限の機能だけの状態で入りました。
その他のクラスの機能は別のプロポーザルとして提案され、ES2015以降に持ち越された形で議論が進められています。

このような合意が取れる最低限の形で機能を進めていくのには、ES4の苦い失敗が背景にあります。
ES4ではECMAScriptに多くの変更を入れることを試みましたが、TC39内でも意見が分かれ最終的に合意できませんでした。
これによりES4の策定に割いた数年分のリソースが無駄となってしまったという経緯があります。[^1]

ES2016以降の策定プロセスでも、すべてのプロポーザルが仕様に入るわけではありません。[^2]
別の代替手段（プロポーザル）が出た場合や後方互換性と保てない場合などにプロポーザルの策定を中断する場合があります。
しかし、この場合でもプロポーザルという単位であるため策定作業の無駄は最小限で済みます。
このようにモジュール化されたプロポーザルは入れ替えがし易いという性質もあります。

## プロポーザルを使う

ECMAScriptの策定プロセスのStage 4に「2つ以上の実装が存在している」という項目があります。
そのためブラウザのJavaScriptエンジンには、策定中にそのプロポーザルが実装されている場合があります。
多くの場合は試験的なフラグ付きで実装されておりフラグを有効化することで、試すことができるようになっています。

またTranspilerやPolyfillといった手段で、プロポーザルの機能をシミュレートできる場合があります。

Transpilerとは、プロポーザルで追加された新しい構文を既存の機能で再現できるようにソースコードを変換するツールのことです。
たとえば、ES2015で`class`構文が導入されましたが、ES5では`class`は予約語であるため構文エラーとなり実行することはできません。
Transpilerでは、`class`構文を含むソースコードを`function`キーワードを使い擬似的に再現するコードへ変換します。
Transpilerとしては[Babel][]や[TypeScript][]などが有名です。

Polyfillとはプロポーザルで追加された新しいメソッドや関数などを実装を提供するライブラリのことです。
たとえば、ES2016では`Array#inclues`というメソッドが追加されましたが、構文とは異なりメソッドはビルトインオブジェクトを書き換えることで実装できます。Polyfillとしては[core-js][]などさまざまなライブラリが存在します。

注意点としてはTranspilerやPolyfillはあくまで既存の機能で新しい機能を再現を試みているだけに過ぎません。
そのため、既存の機能で再現ができないプロポーザルはTranspilerやPolyfillでは再現できません。
また、完全な再現はできていないことがあるためTranspilerやPolyfillをそのプロポーザルを学ぶために使うべきではありません。

## Living StandardとなるECMAScript

停滞せずに進化を続けていくために、Ecma InternationalはECMAScriptの新しいバージョン（ES20XX）を毎年リリースしています。
しかし、この仕様書の元となるデータは[GitHub][tc39/ecma262]で管理されており日々更新されています。
そのため、本当の意味での最新版のECMAScript仕様は<https://tc39.github.io/ecma262/>に公開されています。
このように更新ごとにバージョン番号を付けずに、常に最新版を公開する仕様のことを**Living Standard**と呼びます。

ECMAScriptはLiving Stadardですが、説明したように毎年ECMAScript 2017のようにバージョン番号をつけたものも公開されています。
このバージョン番号は、その時点の最新版のスナップショットのようなものです。
毎年決まった時期にそのときの最新版を元にしたものに対して`ES20XX`とタグを付けて公開しています。

実際に各ブラウザなどはECMAScriptを実装していますが、このときに参照するのは基本的にLiving StandardであるECMAScriptです。
また、PolyfillやTranspilerといった手段で、タグ付けされたECMAScript 20XXがリリースされる前にその機能が利用できることも多いです。
ECMAScriptのバージョンとしてES6ではなくES2015のように西暦をバージョンとして使うようになったのも、Living Standardを意識しての試みです。
このように、タグ付けされたECMAScript 20XXの意味はスナップショットとして意味合いが強くなっています。

このようなLiving Standardの方式はWHATWGというHTML仕様策定を行うワーキンググループでも行われています。
WHATWGはLiving StandardとなるHTML仕様を公開しており、ECMAScriptの最新版はこれに近いものとなります。

ECMAScriptの場合はこのようなLiving Standardの仕組みに加えて、ステージをもった策定プロセスがあるという形になります。

## 策定プロセスを知る意味

こうした策定プロセスを知る意味は何があるのでしょうか？

- 言語を勉強する上では、なぜこのようになったのかというプロセスを知ることができる
    - 仕様書そのものだけではなく、なぜこのような形になったのかというミーティングの議論そのものも公開されています
    - ES2015以降はGitHub上に移動して更新されたため、コミットログやIssue、Pull Requestとより途中経過が分かりやすくなっています
- 膨大な情報から正しいものを見分ける手助けとなる
- 安定したECMAScript以前でも利用できるようになってしまうため、その機能の将来安定かを見分けるため

もちろんすべての仕様やプロポーザルを理解する必要はありません。
しかし、この仕様はなぜこうなったのかということを知りたいと思ったときに、知る方法は持っていることは大切です。

これはECMAScriptだけではなく、ブラウザにおけるHTMLやDOM API、CSSといった仕様にも同様のことがいえます。

ECMAScriptの策定プロセスを意識してみるとほぼすべての新しい機能追加（プロポーザル）は段階を踏んでいることがわかります。
つまりいきなり仕様に新しい機能が増えるのではなくStage 0、1、2、３、4というように仕様へマージという段階を踏んでいます。

ES XXXXという毎年でるスナップショットだけで比較すると毎年数個の新しいProposalがマージされています。
しかし、その背景には数年かかって徐々に進んできた仕様のProposalがあることは意識します。

JavaScriptは広く使われているため、いけんもさまざまです。
情報量は圧倒的に多いですが、その分混乱してしまうことも多いでしょ。
そのため、憶測だけで話をしてしまう人も多くいます。
そのような中で仕様とプロセスという段階をしっておくことは憶測の正しさを確認できる手段となりえます。

基本的にProposalの進捗とそのログには事実です。
このような事実を踏まると応用が聞きます。


[^1]: ES2015の仕様編集者であるAllen Wirfs-Brock氏の書いた[Programming Language Standardization](http://wirfs-brock.com/allen/files/papers/standpats-asianplop2016.pdf)に詳細が書かれています。
[^2]: [Inactive Proposals](https://github.com/tc39/proposals/blob/master/inactive-proposals.md)に策定を中止したプロポーザルの一覧が公開されています。
[^process]: この策定プロセスは<https://tc39.github.io/process-document/>に詳細が書かれています。
[^meeting]: このミーティングの議事録は<https://github.com/tc39/tc39-notes>にて公開されています。
[ES4]: ECMAScript 4は複雑で大きな変更が含まれており、合意を得ることできずに仕様策定が破棄されました。
[Ecma International]: http://www.ecma-international.org/  "Ecma International"
[tc39/proposals]: https://github.com/tc39/proposals  "tc39/proposals: Tracking ECMAScript Proposals"
[tc39/ecma262]: https://github.com/tc39/ecma262  "tc39/ecma262: Status, process, and documents for ECMA262"
[Babel]: https://babeljs.io/  "Babel · The compiler for writing next generation JavaScript"
[TypeScript]: https://www.typescriptlang.org/  "TypeScript - JavaScript that scales."
[core-js]: https://github.com/zloirock/core-js  "zloirock/core-js: Standard Library"
